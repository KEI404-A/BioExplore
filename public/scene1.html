<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>AR-Room</title>
  <meta name="description" content="AR">
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.min.js"></script>
  <script src="https://unpkg.com/networked-aframe@0.14.0/dist/networked-aframe.min.js"></script>
  <script src="https://unpkg.com/networked-aframe@0.14.0/dist/easyrtc-adapter.js"></script>
  <script>
    // Global configuration
    window.NAF_OPTIONS = {
      updateRate: 15, // Update rate in Hz
      useLerp: true,
      useHttps: window.location.protocol === 'https:',
      debug: true
    };
    
    // ICE servers configuration
    const iceServers = [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' },
      { urls: 'stun:stun2.l.google.com:19302' }
    ];
    
    // Initialize EasyRTC with proper configuration
    easyrtc.enableDebug(false);
    easyrtc.setStunServers(iceServers);
    easyrtc.enableVideo(false);
    easyrtc.enableAudio(false);
    easyrtc.enableDataChannels(true);
  </script>

  <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.4/dist/aframe-extras.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/aframe-environment-component@1.5.0/dist/aframe-environment-component.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/gh/c-frame/aframe-cursor-teleport@1.6.0/dist/aframe-cursor-teleport-component.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-blink-controls@0.4.3/dist/aframe-blink-controls.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/gh/AdaRoseCannon/aframe-xr-boilerplate@bca4792/simple-navmesh-constraint.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-gltf-model-plus@1.0.0/dist/gltf-model-plus.min.js"></script>
  <script src="/dist/components.js"></script>
  <script src="/js/joystick.js"></script>
  <script defer src="/dist/ui.js"></script>
  <style>
    /* Ensure body and html allow scrolling */
    html, body {
      margin: 0;
      padding: 0;
      overflow: auto;
      height: auto;
      min-height: 100vh;
    }

    .ui-buttons {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10000;
      display: flex;
      gap: 10px;
    }

    .ui-button {
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border: 1px solid #3a7bd5;
      border-radius: 20px;
      padding: 8px 16px;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.3s ease;
    }

    .ui-button:hover {
      background: rgba(58, 123, 213, 0.9);
    }

    .ui-button i {
      font-size: 16px;
    }

    
    /* Hide avatar selection modals */
    div[class*="naf-centered-fullscreen"], 
    div[class*="avatar-selection"], 
    div[id*="avatar"], 
    .avatar-modal, 
    .avatar-selection-modal {
      display: none !important;
      visibility: hidden !important;
    }

    /* VR Button - Hidden */
    .a-enter-vr-button {
      display: none !important;
    }

    #custom-vr-btn {
      display: none !important;
    }

    /* Popup Pertanyaan */
    .question-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 40px;
      max-width: 900px;
      width: 90%;
      z-index: 20000;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.8s ease-in-out, transform 0.8s ease-in-out;
    }

    .question-popup.show {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%) scale(1);
    }

    .question-popup.hide {
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.9);
      pointer-events: none;
    }

    .question-popup h2 {
      color: #1e40af;
      font-size: 28px;
      margin-bottom: 30px;
      text-align: center;
      font-weight: bold;
    }

    .question-popup .question-item {
      color: #1f2937;
      font-size: 20px;
      margin-bottom: 20px;
      padding: 20px;
      background: rgba(59, 130, 246, 0.1);
      border-radius: 10px;
      border-left: 4px solid #3b82f6;
      line-height: 1.6;
    }

    .question-popup .question-item:last-child {
      margin-bottom: 0;
    }

    /* Kalimat Penjelas */
    .explanation-text {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(59, 130, 246, 0.95);
      color: white;
      padding: 30px 50px;
      border-radius: 15px;
      font-size: 22px;
      z-index: 20001;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.8s ease-in-out;
      text-align: center;
      max-width: 700px;
      width: 90%;
      font-weight: 500;
    }

    .explanation-text.show {
      opacity: 1;
    }

    .explanation-text.hide {
      opacity: 0;
    }

    /* Tombol Mulai Observasi */
    .start-observation-btn {
      position: fixed;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%);
      color: white;
      border: none;
      padding: 18px 40px;
      font-size: 18px;
      font-weight: bold;
      border-radius: 50px;
      cursor: pointer;
      z-index: 20002;
      box-shadow: 0 5px 20px rgba(59, 130, 246, 0.4);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.8s ease-in-out, transform 0.3s ease;
    }

    .start-observation-btn.show {
      opacity: 1;
      pointer-events: auto;
    }

    .start-observation-btn:hover {
      transform: translateX(-50%) scale(1.05);
      box-shadow: 0 8px 25px rgba(59, 130, 246, 0.6);
    }

    .start-observation-btn:active {
      transform: translateX(-50%) scale(0.98);
    }

    /* Video Controls */
    .video-controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 20px;
      border-radius: 10px;
      z-index: 20003;
      display: none;
      align-items: center;
      gap: 15px;
      min-width: 400px;
      max-width: 90%;
    }

    .video-controls.show {
      display: flex;
    }

    .video-control-btn {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: background 0.3s ease;
    }

    .video-control-btn:hover {
      background: rgba(255, 255, 255, 0.4);
    }

    .video-seek-container {
      flex: 1;
      position: relative;
      height: 6px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
      cursor: pointer;
    }

    .video-seek-bar {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      background: #3b82f6;
      border-radius: 3px;
      width: 0%;
      transition: width 0.1s linear;
    }

    .video-seek-handle {
      position: absolute;
      top: 50%;
      left: 0%;
      transform: translate(-50%, -50%);
      width: 14px;
      height: 14px;
      background: white;
      border-radius: 50%;
      cursor: grab;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .video-seek-handle:active {
      cursor: grabbing;
    }

    .video-time {
      color: white;
      font-size: 14px;
      min-width: 100px;
      text-align: center;
      font-family: monospace;
    }

    /* Next Button */
    .next-video-btn {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      border: none;
      padding: 18px 40px;
      font-size: 18px;
      font-weight: bold;
      border-radius: 50px;
      cursor: pointer;
      z-index: 20004;
      box-shadow: 0 5px 20px rgba(16, 185, 129, 0.4);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.8s ease-in-out, transform 0.3s ease;
    }

    .next-video-btn.show {
      opacity: 1;
      pointer-events: auto;
    }

    .next-video-btn:hover {
      transform: translateX(-50%) scale(1.05);
      box-shadow: 0 8px 25px rgba(16, 185, 129, 0.6);
    }

    .next-video-btn:active {
      transform: translateX(-50%) scale(0.98);
    }

    /* Finish Button */
    .finish-btn {
      position: fixed;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      border: none;
      padding: 18px 40px;
      font-size: 18px;
      font-weight: bold;
      border-radius: 50px;
      cursor: pointer;
      z-index: 20005;
      box-shadow: 0 5px 20px rgba(16, 185, 129, 0.4);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.8s ease-in-out, transform 0.3s ease;
    }

    .finish-btn.show {
      opacity: 1;
      pointer-events: auto;
    }

    .finish-btn:hover {
      transform: translateX(-50%) scale(1.05);
      box-shadow: 0 8px 25px rgba(16, 185, 129, 0.6);
    }

    .finish-btn:active {
      transform: translateX(-50%) scale(0.98);
    }

    /* Done Button */
    .done-btn {
      position: fixed;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      color: white;
      border: none;
      padding: 18px 40px;
      font-size: 18px;
      font-weight: bold;
      border-radius: 50px;
      cursor: pointer;
      z-index: 20007;
      box-shadow: 0 5px 20px rgba(59, 130, 246, 0.4);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.8s ease-in-out, transform 0.3s ease;
    }

    .done-btn.show {
      opacity: 1;
      pointer-events: auto;
    }

    .done-btn:hover {
      transform: translateX(-50%) scale(1.05);
      box-shadow: 0 8px 25px rgba(59, 130, 246, 0.6);
    }

    .done-btn:active {
      transform: translateX(-50%) scale(0.98);
    }

    /* Final Question Popup */
    .final-question-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.9);
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 40px;
      max-width: 900px;
      width: 90%;
      z-index: 20006;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.8s ease-in-out, transform 0.8s ease-in-out;
    }

    .final-question-popup.show {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%) scale(1);
    }

    .final-question-popup.hide {
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.9);
      pointer-events: none;
    }

    .final-question-popup .question-item {
      color: #1f2937;
      font-size: 20px;
      margin-bottom: 20px;
      padding: 20px;
      background: rgba(59, 130, 246, 0.1);
      border-radius: 10px;
      border-left: 4px solid #3b82f6;
      line-height: 1.6;
    }

    .final-question-popup .question-item:last-child {
      margin-bottom: 0;
    }
  </style>
</head>

<body>

  <!-- Popup Pertanyaan -->
  <div id="questionPopup" class="question-popup">
    <h2>Sub Driving Question:</h2>
    <div class="question-item">Apakah semua zat yang kita konsumsi diperlukan oleh tubuh?</div>
    <div class="question-item">Mengapa keringat bisa bau padahal warnanya bening?</div>
  </div>

  <!-- Kalimat Penjelas -->
  <div id="explanationText" class="explanation-text">
    Berikut Video dan beberapa Gambar yang akan menjelaskan pertanyaan tersebut
  </div>

  <!-- Tombol Mulai Observasi -->
  <button id="startObservationBtn" class="start-observation-btn">
    Mulai Observasi
  </button>

  <!-- Video Controls -->
  <div id="videoControls" class="video-controls">
    <button id="playPauseBtn" class="video-control-btn">‚è∏</button>
    <div class="video-seek-container" id="seekContainer">
      <div class="video-seek-bar" id="seekBar"></div>
      <div class="video-seek-handle" id="seekHandle"></div>
    </div>
    <div class="video-time" id="videoTime">0:00 / 0:00</div>
  </div>

  <!-- Next Video Button -->
  <button id="nextVideoBtn" class="next-video-btn">
    Next
  </button>

  <!-- Finish Button -->
  <button id="finishBtn" class="finish-btn">
    Finish
  </button>

  <!-- Final Question Popup -->
  <div id="finalQuestionPopup" class="final-question-popup">
    <div class="question-item">Menurutmu, apakah keringat mengandung zat berbahaya?</div>
    <div class="question-item">Mengapa keringat sebagian orang berbau?</div>
  </div>

  <!-- Done Button -->
  <button id="doneBtn" class="done-btn">
    Done
  </button>

  <!-- Virtual Gamepad for Mobile -->
  <div id="mobile-controls"
    style="position: fixed; bottom: 30px; left: 20px; z-index: 1000; display: none; touch-action: none; -webkit-tap-highlight-color: transparent;">
    <!-- Joystick Control -->
    <div id="joystick"
      style="width: 180px; height: 180px; background: rgba(255, 255, 255, 0.2); border-radius: 50%; position: relative; overflow: visible;">
      <div id="joystick-knob"
        style="width: 120px; height: 120px; background: rgba(255, 255, 255, 0.5); border-radius: 50%; position: absolute; left: 30px; top: 30px; transition: transform 0.1s ease-out; touch-action: none; pointer-events: none;">
      </div>
    </div>
  </div>

  <a-scene light="defaultLightsEnabled:false" renderer="stencil:true; antialias: true;" vr-mode-ui="enabled: false"
    webxr="requiredFeatures: local-floor; referenceSpaceType: local-floor;" networked-scene="
        connectOnLoad: false;
        room: forest;
        debug: true;
        adapter: easyrtc;
        onConnect: onConnect;
        audio: false;
        video: false;
    " shadow="type: pcfsoft" gltf-model="meshoptDecoderPath:https://unpkg.com/meshoptimizer@0.19.0/meshopt_decoder.js"
    raycaster="far: 100; objects: .clickable,[link];" cursor="rayOrigin: mouse">
    <a-assets>
      <template id="avatar-template">
        <a-entity player-info>
          <a-entity class="model" animation-mixer>
            <a-text class="nametag" align="center" value="?" position="0 2.1 0" scale=".5 .5 .5"></a-text>
          </a-entity>
          <a-entity class="camera" position="0 1.6 0"></a-entity>
        </a-entity>
      </template>
      <img id="thumbJapan" crossorigin="anonymous" src="https://cdn.aframe.io/link-traversal/thumbs/japan.png" />
      <img id="thumbForest" crossorigin="anonymous" src="https://cdn.aframe.io/link-traversal/thumbs/forest.png" />
      <!-- Images for Virtual Lab -->
      <img id="keringatImage" crossorigin="anonymous" src="assets/gambar/keringat.jpg" 
           onload="console.log('Keringat image loaded successfully')" 
           onerror="console.error('Failed to load keringat image')" />
      <img id="kulitImage" crossorigin="anonymous" src="assets/gambar/kulit.webp" 
           onload="console.log('Kulit image loaded successfully')" 
           onerror="console.error('Failed to load kulit image')" />
      <img id="kulit2Image" crossorigin="anonymous" src="assets/gambar/kulit2.webp" 
           onload="console.log('Kulit2 image loaded successfully')" 
           onerror="console.error('Failed to load kulit2 image')" />
      <!-- Video for white screen -->
      <video id="excretoryVideo" playsinline preload="none" crossorigin="anonymous">
        <source src="assets/video/EXCRETORY SYSTEM üßçüèª_‚ôÇÔ∏è Urinary System and Sweat Glands üß¨ Science for Kids.mp4" type="video/mp4">
      </video>
      <!-- Video 2 for white screen -->
      <video id="bodyOdorVideo" playsinline preload="none" crossorigin="anonymous">
        <source src="assets/video/What causes body odor_ - Mel Rosenberg.mp4" type="video/mp4">
      </video>
    </a-assets>

    <a-entity id="scene">
      <!-- School building with collision -->
      <a-entity id="school-group" position="0 -11 0">
        <a-gltf-model src="assets/scene1/sekolah.glb" scale="2 2 2" rotation="0 0 0" class="collidable"></a-gltf-model>
        <!-- Collision box for school building -->
        <a-box class="collidable" position="0 8 0" width="12" height="24" depth="12" visible="false"></a-box>
      </a-entity>
      <a-plane class="ground" position="0 0 0" rotation="-90 0 0" width="100" height="100" visible="true"></a-plane>
      <a-entity light="type:ambient;intensity:0.5"></a-entity>

      <!-- Virtual Lab 3D Model -->
      <a-entity id="virtual-lab" position="16 0 7" rotation="0 90 0">
        <a-gltf-model src="assets/map/Virtual Lab.glb" scale="1 1 1" class="collidable"></a-gltf-model>
        <!-- Collision boxes for Virtual Lab (walls, furniture, doors, etc.) -->
        <!-- Main room collision - adjust based on actual model size -->
        <a-box class="collidable" position="0 2.5 0" width="20" height="5" depth="20" visible="false"></a-box>
        <!-- Left wall -->
        <a-box class="collidable" position="-10 2.5 0" width="0.2" height="5" depth="20" visible="false"></a-box>
        <!-- Right wall -->
        <a-box class="collidable" position="10 2.5 0" width="0.2" height="5" depth="20" visible="false"></a-box>
        <!-- Back wall -->
        <a-box class="collidable" position="0 2.5 -10" width="20" height="5" depth="0.2" visible="false"></a-box>
        <!-- Front wall (with door opening) -->
        <a-box class="collidable" position="-5 2.5 10" width="5" height="5" depth="0.2" visible="false"></a-box>
        <a-box class="collidable" position="5 2.5 10" width="5" height="5" depth="0.2" visible="false"></a-box>
        <!-- Table collision -->
        <a-box class="collidable" position="0 0.4 0" width="4" height="0.8" depth="2" visible="false"></a-box>
        <!-- Chairs collision (4 chairs around table) -->
        <a-box class="collidable" position="-2.5 0.4 0" width="0.5" height="1" depth="0.5" visible="false"></a-box>
        <a-box class="collidable" position="2.5 0.4 0" width="0.5" height="1" depth="0.5" visible="false"></a-box>
        <a-box class="collidable" position="0 0.4 -1.5" width="0.5" height="1" depth="0.5" visible="false"></a-box>
        <a-box class="collidable" position="0 0.4 1.5" width="0.5" height="1" depth="0.5" visible="false"></a-box>
        
        <!-- Video on white screen (back wall) -->
        <!-- Position relative to virtual-lab entity -->
        <!-- Initially hidden, will show after "Mulai Observasi" button is clicked -->
        <a-video 
          id="whiteScreenVideo"
          class="observation-content"
          src="#excretoryVideo" 
          width="3.3" 
          height="2.2" 
          position="3 1.5 -5" 
          rotation="0 180 0"
          material="side: double; shader: flat; opacity: 0"
          visible="false">
        </a-video>
        
        <!-- Images for Virtual Lab -->
        <!-- Image 1: Keringat -->
        <a-image
          id="keringatImageEntity"
          class="observation-content"
          src="#keringatImage"
          width="3"
          height="2"
          position="0.5 1.5 -12"
          rotation="0 90 0"
          material="side: double; shader: flat; opacity: 0"
          visible="false">
        </a-image>
        
        <!-- Image 2: Kulit -->
        <a-image
          id="kulitImageEntity"
          class="observation-content"
          src="#kulitImage"
          width="2"
          height="2"
          position="0.5 1.5 -9"
          rotation="0 90 0"
          material="side: double; shader: flat; opacity: 0"
          visible="false">
        </a-image>

        <a-image
          id="kulit2ImageEntity"
          class="observation-content"
          src="#kulit2Image"
          width="2"
          height="2"
          position="0.5 1.5 -9"
          rotation="0 90 0"
          material="side: double; shader: flat; opacity: 0"
          visible="false">
        </a-image>
        
        
        <!-- Images for observation (will be added here) -->
        <!-- <a-image id="observationImage1" ... visible="false"></a-image> -->
      </a-entity>

      <!-- Lab Biologi 3D Model (initially hidden) -->
      <a-entity id="lab-biologi" position="0 0 0" rotation="0 0 0" visible="false">
        <a-gltf-model src="assets/map/LabBiologi.compressed.glb" scale="1 1 1"></a-gltf-model>
      </a-entity>


      <!-- Car collision system -->
      <a-entity id="car-group" position="0 0 2" rotation="0 180 0">
        <!-- Main collision body for the car -->
        <!-- Visual model for the car -->
        <a-entity id="ferrari" gltf-model="url(assets/scene1/ferrari.glb)" position="0 0 0"
          scale="1.3 1.3 1.3"></a-entity>
        <!-- Arrow indicator for car -->
        <a-entity id="car-arrow" gltf-model="url(assets/scene1/arrow.glb)" position="0 2.5 0" rotation="0 0 0"
          scale="0.7 0.7 0.7" visible="false">
        </a-entity>

        <!-- Force indicator for car -->
        <a-text id="car-force-indicator" value="F: 0N" position="0 3.2 0" align="center" color="#FF5722"
          font="kelsonsans" width="8" visible="false">
        </a-text>

        <!-- Acceleration indicator for car -->
        <a-text id="car-acceleration-indicator" value="A: 0 m/s^2" position="0 2.8 0" align="center" color="#4CAF50"
          font="kelsonsans" width="8" visible="false">
        </a-text>
        <!-- NPC Pusher -->
        <a-entity id="npc-pusher" gltf-model="url(assets/scene1/push.glb)" position="0 0 3.1" rotation="0 180 0"
          scale="0.01 0.01 0.01" animation-mixer="clip: mixamo.com; loop: repeat" visible="false"></a-entity>
      </a-entity>

      <!-- Cart model with collision -->
      <a-entity id="cart-group" position="3 0 3" rotation="0 180 0">
        <!-- Visual model for the cart -->
        <a-entity id="cart" gltf-model="url(assets/scene1/cart.glb)" scale="0.01 0.01 0.01" rotation="0 180 0"
          animation-mixer="clip: Static Pose; loop: infinite">
        </a-entity>
        <!-- Arrow indicator for cart -->
        <a-entity id="cart-arrow" gltf-model="url(assets/scene1/arrow.glb)" position="0 1.5 0" rotation="0 180 0"
          scale="0.3 0.3 0.3" visible="false">
        </a-entity>

        <!-- Force indicator for cart -->
        <a-text id="cart-force-indicator" value="F: 0N" position="0 2.2 0" align="center" color="#FF5722"
          font="kelsonsans" width="8" visible="false">
        </a-text>

        <!-- Acceleration indicator for cart -->
        <a-text id="cart-acceleration-indicator" value="A: 0 m/s^2" position="0 1.8 0" align="center" color="#4CAF50"
          font="kelsonsans" width="8" visible="false">
        </a-text>
        <!-- NPC Pusher Cart -->
        <a-entity id="npc-pusher-cart" gltf-model="url(assets/scene1/push.glb)" position="0 0 2.2" rotation="0 180 0"
          scale="0.01 0.01 0.01" animation-mixer="clip: mixamo.com; loop: repeat" visible="false"></a-entity>
      </a-entity>


      <!-- Portal back to vr.html -->
      <a-text value="Kembali ke Beranda" position="0 1.5 -8" align="center" color="#FFFFFF" font="kelsonsans" width="5"
        look-at="#player"></a-text>
      <a-link link="on:click" href="vr.html" title="Kembali ke Lobby" image="#thumbForest" position="4 1 -1"
        rotation="0 0 0" class="clickable" event-set__mouseenter="material.opacity: 0.8"
        event-set__mouseleave="material.opacity: 0.6">
      </a-link>
    </a-entity>

    <!-- Jump Controls Component -->
    <script>
      AFRAME.registerComponent('jump-controls', {
        schema: {
          jumpHeight: { type: 'number', default: 1.0 },
          jumpDuration: { type: 'number', default: 800 },
          isJumping: { type: 'boolean', default: false },
          initialY: { type: 'number', default: 1.6 }
        },
        init: function() {
          // Add event listeners for keyboard and touch
          document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !this.data.isJumping) {
              this.jump();
            }
          });
          
          // Touch support for mobile
          document.addEventListener('touchend', (e) => {
            if (!this.data.isJumping && e.target.id === 'jump-button') {
              this.jump();
            }
          });
          
          // Store initial Y position
          this.data.initialY = this.el.getAttribute('position').y || 1.6;
        },
        jump: function() {
          if (this.data.isJumping) return;
          
          this.data.isJumping = true;
          const startTime = Date.now();
          const startY = this.el.getAttribute('position').y;
          const jumpHeight = this.data.jumpHeight;
          const jumpDuration = this.data.jumpDuration;
          
          const animateJump = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / jumpDuration, 1);
            const jumpProgress = Math.sin(progress * Math.PI);
            const currentY = startY + (jumpProgress * jumpHeight);
            
            // Update position
            const currentPos = this.el.getAttribute('position');
            this.el.setAttribute('position', {
              x: currentPos.x,
              y: currentY,
              z: currentPos.z
            });
            
            // Continue animation or complete
            if (progress < 1) {
              requestAnimationFrame(animateJump);
            } else {
              // Reset to initial position
              this.el.setAttribute('position', {
                x: currentPos.x,
                y: this.data.initialY,
                z: currentPos.z
              });
              this.data.isJumping = false;
            }
          };
          
          requestAnimationFrame(animateJump);
        }
      });
    </script>

    <a-entity id="rig" position="6 0 3" rotation="0 -90 0" collider="distance: 0.3" movement-controls="fly:false;"
      networked="template:#avatar-template;attachTemplateToLocal:false" player-info jump-controls>
      <a-entity id="player" class="camera" camera position="0 1.6 0" look-controls pointer-lock>
        <a-box obb-collider visible="false" height="0.4" depth="0.4" width="0.4"></a-box>
        <!-- Ring cursor for better interaction -->
        <a-entity position="0 0 -1" geometry="primitive: ring; radiusInner: 0.018; radiusOuter: 0.025"
          material="shader: flat; opacity: 0.9" cursor="fuse: true; fuseTimeout: 1200"
          raycaster="objects: .clickable; far: 20;"
          animation__fuse="property: scale; startEvents: fusing; from: 1 1 1; to: 0.2 0.2 0.2; dur: 1200; easing: linear"
          animation__reset="property: scale; startEvents: mouseleave; to: 1 1 1; dur: 120" id="main-cursor">
        </a-entity>
      </a-entity>
      <a-entity id="left-hand" networked-hand-controls="hand: left" laser-controls="hand: left"></a-entity>
      <a-entity id="right-hand" networked-hand-controls="hand:right" laser-controls="hand: right"></a-entity>
    </a-entity>
  </a-scene>

  <script>
    // Cursor Listener Component for 3D UI interactions
    AFRAME.registerComponent('cursor-listener', {
      init: function () {
        this.el.addEventListener('click', this.onClick.bind(this));
        this.el.addEventListener('fuse', this.onClick.bind(this)); // Add fuse event support
        this.el.addEventListener('mouseenter', this.onMouseEnter.bind(this));
        this.el.addEventListener('mouseleave', this.onMouseLeave.bind(this));
        console.log('Cursor listener initialized for element:', this.el.id);
      },
      onClick: function (evt) {
        console.log('=== BUTTON CLICKED ===');
        console.log('Element clicked:', this.el.id);
        console.log('Event details:', evt);
        console.log('physicsSimulation3D available:', !!physicsSimulation3D);
        console.log('physicsSimulation3D:', physicsSimulation3D);

        // Physics panel buttons removed - no action needed
      },
      onMouseEnter: function (evt) {
        console.log('Mouse enter:', this.el.id);
      },
      onMouseLeave: function (evt) {
        console.log('Mouse leave:', this.el.id);
      }
    });

    // Component to make one entity follow another
    AFRAME.registerComponent('follow', {
      schema: { target: { type: 'selector' } },
      tick: function () {
        if (!this.data.target) return;
        this.el.object3D.position.copy(this.data.target.object3D.position);
        this.el.object3D.quaternion.copy(this.data.target.object3D.quaternion);
      },
    });

    // 3D Slider Component
    AFRAME.registerComponent('slider-3d', {
      schema: {
        min: { default: 0 },
        max: { default: 100 },
        value: { default: 50 },
        width: { default: 3 },
        target: { type: 'selector' }
      },
      init: function () {
        this.isDragging = false;
        this.startPosition = new THREE.Vector3();
        this.currentPosition = new THREE.Vector3();

        this.el.addEventListener('mousedown', this.onMouseDown.bind(this));
        this.el.addEventListener('mouseup', this.onMouseUp.bind(this));
        this.el.sceneEl.addEventListener('mousemove', this.onMouseMove.bind(this));

        // Set initial position based on value
        this.updateSliderPosition();
      },
      onMouseDown: function (evt) {
        this.isDragging = true;
        this.el.object3D.getWorldPosition(this.startPosition);
      },
      onMouseUp: function (evt) {
        this.isDragging = false;
      },
      onMouseMove: function (evt) {
        if (!this.isDragging) return;

        const raycaster = this.el.sceneEl.systems.raycaster.raycaster;
        const camera = this.el.sceneEl.camera;

        // Calculate intersection with slider plane
        const slider = this.el;
        const parent = slider.parentNode;
        const parentPos = new THREE.Vector3();
        parent.object3D.getWorldPosition(parentPos);

        // Calculate local X position relative to slider track
        const halfWidth = this.data.width / 2;
        const localX = THREE.MathUtils.clamp(
          evt.detail.intersection.point.x - parentPos.x,
          -halfWidth,
          halfWidth
        );

        // Update slider position
        slider.setAttribute('position', `${localX} ${slider.getAttribute('position').y} ${slider.getAttribute('position').z}`);

        // Calculate value based on position
        const normalizedPos = (localX + halfWidth) / this.data.width;
        this.data.value = this.data.min + normalizedPos * (this.data.max - this.data.min);

        // Update display
        this.updateDisplay();
      },
      updateSliderPosition: function () {
        const normalizedValue = (this.data.value - this.data.min) / (this.data.max - this.data.min);
        const halfWidth = this.data.width / 2;
        const posX = -halfWidth + normalizedValue * this.data.width;

        const currentPos = this.el.getAttribute('position');
        this.el.setAttribute('position', `${posX} ${currentPos.y} ${currentPos.z}`);
      },
      updateDisplay: function () {
        if (this.data.target) {
          this.data.target.setAttribute('value', Math.round(this.data.value).toString());
        }
      }
    });

    // Simple slider component for 3D interface
    AFRAME.registerComponent('simple-slider', {
      schema: {
        min: { default: 0 },
        max: { default: 100 },
        value: { default: 50 },
        step: { default: 10 }
      },
      init: function () {
        this.el.addEventListener('click', this.onClick.bind(this));
      },
      onClick: function (evt) {
        // Cycle through values on click
        this.data.value += this.data.step;
        if (this.data.value > this.data.max) {
          this.data.value = this.data.min;
        }
        this.updatePosition();
        this.el.emit('valuechange', { value: this.data.value });
      },
      updatePosition: function () {
        const normalizedValue = (this.data.value - this.data.min) / (this.data.max - this.data.min);
        const halfWidth = 1.5; // 3/2
        const posX = -halfWidth + normalizedValue * 3;

        const currentPos = this.el.getAttribute('position');
        this.el.setAttribute('position', `${posX} ${currentPos.y} ${currentPos.z}`);
      }
    });

    // Player collider: stops the player from penetrating any .collidable object
    AFRAME.registerComponent('collider', {
      schema: {
        distance: { default: 1.2 },
        debug: { default: false }
      },
      init: function () {
        this.raycaster = new THREE.Raycaster();
        this.lastSafePosition = new THREE.Vector3();
        this.directions = [
          new THREE.Vector3(0, 0, -1), // forward
          new THREE.Vector3(0, 0, 1), // backward
          new THREE.Vector3(-1, 0, 0), // left
          new THREE.Vector3(1, 0, 0), // right
          new THREE.Vector3(-0.7, 0, -0.7), // diagonal front-left
          new THREE.Vector3(0.7, 0, -0.7), // diagonal front-right
          new THREE.Vector3(-0.7, 0, 0.7), // diagonal back-left
          new THREE.Vector3(0.7, 0, 0.7), // diagonal back-right
        ];
        this.el.addEventListener('loaded', () => {
          this.el.object3D.getWorldPosition(this.lastSafePosition);
        });
      },
      tick: function (time, delta) {
        const collidableEls = this.el.sceneEl.querySelectorAll('.collidable');
        if (collidableEls.length === 0) return;

        const collidables = [];
        collidableEls.forEach((el) => {
          if (el.object3D) {
            collidables.push(el.object3D);
          }
        });

        let collision = false;
        const currentPosition = new THREE.Vector3();
        this.el.object3D.getWorldPosition(currentPosition);

        for (const dir of this.directions) {
          const worldDir = dir.clone().applyQuaternion(this.el.object3D.quaternion);
          this.raycaster.set(currentPosition, worldDir);
          this.raycaster.far = this.data.distance;
          const intersects = this.raycaster.intersectObjects(collidables, true);

          if (intersects.length > 0 && intersects[0].distance < this.data.distance) {
            const hitEl = intersects[0].object.el;

            if (this.data.debug) {
              console.log('Collision detected with:', hitEl ? hitEl.id : 'unknown', 'distance:', intersects[0].distance);
            }

            // Handle pushable objects
            if (hitEl && hitEl.components && hitEl.components.pushable) {
              const pushStrength = 0.02;
              const pushVector = worldDir.clone().multiplyScalar(pushStrength * delta);
              hitEl.components.pushable.push(pushVector);
              if (this.data.debug) {
                console.log('Pushing object:', hitEl.id, 'with vector:', pushVector);
              }
            }

            // Prevent penetration
            this.el.object3D.position.copy(this.lastSafePosition);
            collision = true;
            break;
          }
        }

        if (!collision) {
          this.el.object3D.getWorldPosition(this.lastSafePosition);
        }
      },
    });

    // Pushable component: handles its own gravity and can be pushed
    AFRAME.registerComponent('pushable', {
      init: function () {
        this.raycaster = new THREE.Raycaster();
        this.downVector = new THREE.Vector3(0, -1, 0);
        this.velocity = new THREE.Vector3();
        this.friction = 0.92;
      },
      push: function (vector) {
        // Only allow pushing from front or back, not sides
        if (Math.abs(vector.x) > Math.abs(vector.z)) {
          return;
        }
        this.velocity.add(vector);

        // If this element has a parent group, move the entire group
        const parentGroup = this.el.parentNode;
        if (parentGroup && parentGroup.id === 'car-group') {
          parentGroup.object3D.position.add(vector);
        } else {
          this.el.object3D.position.add(vector);
        }

        // Update all connected objects (like the visual ferrari model)
        const followingElements = this.el.sceneEl.querySelectorAll('[follow]');
        followingElements.forEach((follower) => {
          const followComponent = follower.components.follow;
          if (followComponent && followComponent.data.target === this.el) {
            follower.object3D.position.copy(this.el.object3D.position);
          }
        });
      },
      tick: function () {
        // Apply friction
        this.velocity.multiplyScalar(this.friction);

        // Apply small remaining velocity
        if (this.velocity.length() > 0.001) {
          const parentGroup = this.el.parentNode;
          if (parentGroup && parentGroup.id === 'car-group') {
            parentGroup.object3D.position.add(this.velocity.clone().multiplyScalar(0.1));
          } else {
            this.el.object3D.position.add(this.velocity.clone().multiplyScalar(0.1));
          }
        }

        // Apply gravity/ground constraint
        const groundEls = this.el.sceneEl.querySelectorAll('.ground, .environmentGround');
        if (groundEls.length === 0) return;
        const grounds = [];
        groundEls.forEach((el) => grounds.push(el.object3D));

        this.raycaster.set(this.el.object3D.position, this.downVector);
        const intersects = this.raycaster.intersectObjects(grounds, true);
        if (intersects.length > 0) {
          const height = this.el.getAttribute('height') || this.el.getAttribute('geometry')?.height || 0.1;
          this.el.object3D.position.y = intersects[0].point.y + height / 2;
        }
      },
    });

    // Physics Object Component
    AFRAME.registerComponent('physics-object', {
      schema: {
        mass: { default: 1 }
      },
      init: function () {
        this.velocity = new THREE.Vector3();
        this.acceleration = new THREE.Vector3();
        this.appliedForce = new THREE.Vector3();
        this.isMoving = false;
        this.distanceTraveled = 0;
        this.startPosition = new THREE.Vector3();
        this.targetDistance = 0;
        this.friction = 0.995; // Reduced friction for better movement
        this.maxValues = {
          acceleration: 0,
          velocity: 0,
          distance: 0
        }; // Store maximum values achieved
        this.lastForceAppliedTime = 0;
        this.shouldKeepDisplayData = false; // Flag to keep data displayed
        this.inputForce = 0; // Store the input force value for display

        // Wait for the element to be loaded before capturing start position
        this.el.addEventListener('loaded', () => {
          setTimeout(() => this.captureStartPosition(), 500);
        });

        // If already loaded, capture immediately
        if (this.el.hasLoaded) {
          setTimeout(() => this.captureStartPosition(), 500);
        }
      },
      captureStartPosition: function () {
        // Get position from parent group if it exists
        const parentGroup = this.el.parentNode;
        if (parentGroup && (parentGroup.id === 'car-group' || parentGroup.id === 'cart-group')) {
          const pos = parentGroup.getAttribute('position');
          this.startPosition.set(pos.x, pos.y, pos.z);
        } else {
          const pos = this.el.getAttribute('position');
          this.startPosition.set(pos.x, pos.y, pos.z);
        }
        console.log(`Start position captured for ${this.el.id}:`, this.startPosition);
      },
      applyForce: function (force, targetDistance) {
        this.appliedForce.copy(force);
        this.acceleration.copy(force).divideScalar(this.data.mass);
        this.isMoving = true;
        this.distanceTraveled = 0;
        this.targetDistance = targetDistance;
        this.captureStartPosition();
        this.lastForceAppliedTime = Date.now();
        this.shouldKeepDisplayData = true; // Keep data displayed until manual reset

        // Store the actual input force value for display
        this.inputForce = force.length() / 50; // Reverse the multiplication done in PhysicsSimulation3D

        // Reset max values when new force is applied
        this.maxValues.acceleration = 0;
        this.maxValues.velocity = 0;
        this.maxValues.distance = 0;

        console.log(`Applying force to ${this.el.id}:`, {
          inputForce: this.inputForce,
          actualForce: force,
          mass: this.data.mass,
          acceleration: this.acceleration,
          targetDistance: targetDistance
        });

        // Collider bodies removed - no action needed

        // Show force and acceleration indicators immediately
        this.updateIndicators();
      },
      tick: function (time, delta) {
        if (!this.isMoving) return;

        const deltaTime = delta / 1000; // Convert to seconds

        // Apply acceleration to velocity
        this.velocity.add(this.acceleration.clone().multiplyScalar(deltaTime));

        // Apply friction
        this.velocity.multiplyScalar(this.friction);

        // Update position - move the parent group if it exists
        const movement = this.velocity.clone().multiplyScalar(deltaTime);
        const parentGroup = this.el.parentNode;

        let currentPos;
        if (parentGroup && (parentGroup.id === 'car-group' || parentGroup.id === 'cart-group')) {
          currentPos = parentGroup.getAttribute('position');
          const newPos = {
            x: currentPos.x + movement.x,
            y: currentPos.y + movement.y,
            z: currentPos.z + movement.z
          };
          parentGroup.setAttribute('position', newPos);
          console.log(`Moving ${parentGroup.id} from`, currentPos, 'to', newPos, 'movement:', movement);
          this.distanceTraveled = Math.sqrt(
            Math.pow(newPos.x - this.startPosition.x, 2) +
            Math.pow(newPos.y - this.startPosition.y, 2) +
            Math.pow(newPos.z - this.startPosition.z, 2)
          );
        } else {
          currentPos = this.el.getAttribute('position');
          const newPos = {
            x: currentPos.x + movement.x,
            y: currentPos.y + movement.y,
            z: currentPos.z + movement.z
          };
          this.el.setAttribute('position', newPos);
          console.log(`Moving ${this.el.id} from`, currentPos, 'to', newPos, 'movement:', movement);
          this.distanceTraveled = Math.sqrt(
            Math.pow(newPos.x - this.startPosition.x, 2) +
            Math.pow(newPos.y - this.startPosition.y, 2) +
            Math.pow(newPos.z - this.startPosition.z, 2)
          );
        }

        // Stop if target distance reached or velocity is very small
        if (this.distanceTraveled >= this.targetDistance || this.velocity.length() < 0.01) {
          this.isMoving = false;
          this.velocity.set(0, 0, 0);

          // Collider bodies removed - no action needed
        }

        // Update maximum values achieved during movement
        const currentAccel = this.acceleration.length();
        const currentVel = this.velocity.length();
        const currentDist = this.distanceTraveled;

        if (currentAccel > this.maxValues.acceleration) {
          this.maxValues.acceleration = currentAccel;
        }
        if (currentVel > this.maxValues.velocity) {
          this.maxValues.velocity = currentVel;
        }
        if (currentDist > this.maxValues.distance) {
          this.maxValues.distance = currentDist;
        }

        // Update UI and arrow
        this.updateUI();
        this.updateArrow();
        this.updateIndicators();
      },
      updateIndicators: function () {
        const objectType = this.el.id.includes('ferrari') ? 'car' : 'cart';

        // Get force and acceleration indicators
        const forceIndicator = document.getElementById(`${objectType}-force-indicator`);
        const accelIndicator = document.getElementById(`${objectType}-acceleration-indicator`);

        if (this.shouldKeepDisplayData && this.inputForce) {
          // Show indicators with input values
          if (forceIndicator) {
            forceIndicator.setAttribute('value', `F: ${this.inputForce.toFixed(0)}N`);
            forceIndicator.setAttribute('visible', true);
          }

          if (accelIndicator) {
            // Calculate theoretical acceleration: F = ma, so a = F/m
            const theoreticalAccel = this.inputForce / this.data.mass;
            accelIndicator.setAttribute('value', `a: ${theoreticalAccel.toFixed(2)} m/s^2`);
            accelIndicator.setAttribute('visible', true);
          }
        } else {
          // Hide indicators when no force applied or after reset
          if (forceIndicator) forceIndicator.setAttribute('visible', false);
          if (accelIndicator) accelIndicator.setAttribute('visible', false);
        }
      },
      updateUI: function () {
        const objectType = this.el.id.includes('ferrari') ? 'car' : 'cart';

        // Update 3D UI elements instead of HTML elements
        requestAnimationFrame(() => {
          const accelEl = document.getElementById(`${objectType}-acceleration-3d`);
          const velocityEl = document.getElementById(`${objectType}-velocity-3d`);
          const distanceEl = document.getElementById(`${objectType}-distance-3d`);

          // If we should keep display data (not manually reset), show values based on input
          if (this.shouldKeepDisplayData) {
            if (accelEl && this.inputForce) {
              // Show theoretical acceleration based on input force: a = F/m
              const theoreticalAccel = this.inputForce / this.data.mass;
              accelEl.setAttribute('value', `${theoreticalAccel.toFixed(2)} m/s^2`);
            }
            if (velocityEl) velocityEl.setAttribute('value', `${this.maxValues.velocity.toFixed(2)} m/s`);
            if (distanceEl) distanceEl.setAttribute('value', `${this.maxValues.distance.toFixed(2)} m`);
          } else {
            // Show zero values when reset
            if (accelEl) accelEl.setAttribute('value', `0.00 m/s^2`);
            if (velocityEl) velocityEl.setAttribute('value', `0.00 m/s`);
            if (distanceEl) distanceEl.setAttribute('value', `0.00 m`);
          }

          console.log(`3D UI Updated for ${objectType} (${this.el.id}):`, {
            mass: this.data.mass,
            inputForce: this.inputForce || 0,
            theoreticalAcceleration: this.inputForce ? (this.inputForce / this.data.mass).toFixed(2) : '0.00',
            maxVelocity: this.shouldKeepDisplayData ? this.maxValues.velocity.toFixed(2) : '0.00',
            maxDistance: this.shouldKeepDisplayData ? this.maxValues.distance.toFixed(2) : '0.00',
            keepingData: this.shouldKeepDisplayData
          });
        });
      },
      updateArrow: function () {
        const objectType = this.el.id.includes('ferrari') ? 'car' : 'cart';
        const arrow = document.getElementById(`${objectType}-arrow`);

        console.log(`updateArrow called for ${this.el.id}, objectType: ${objectType}, arrow found: ${!!arrow}`);
        console.log(`Current acceleration magnitude: ${this.acceleration.length()}`);
        console.log(`Current velocity magnitude: ${this.velocity.length()}`);
        console.log(`Is moving: ${this.isMoving}`);

        if (!arrow) {
          console.error(`Arrow not found for ${objectType}`);
          return;
        }

        // Show arrow if there's any acceleration data (even when stopped)
        if (this.shouldKeepDisplayData && this.inputForce > 0) {
          arrow.setAttribute('visible', true);

          // Scale arrow based on input force (more meaningful scaling)
          const forceMagnitude = this.inputForce;
          const minScale = 0.3;
          const maxScale = 2.0;
          const scaleFactor = 0.01; // Scale factor for force

          // Scale based on input force
          let scale = minScale + (forceMagnitude * scaleFactor);
          scale = Math.max(minScale, Math.min(maxScale, scale));

          console.log(`${objectType} - Input Force: ${forceMagnitude}N, Arrow Scale: ${scale.toFixed(2)}`);

          arrow.setAttribute('scale', `${scale} ${scale} ${scale}`);

          // Point arrow in direction of movement (use last known direction if stopped)
          if (this.isMoving && this.velocity.length() > 0.01) {
            const direction = this.velocity.clone().normalize();
            let angle = Math.atan2(direction.x, direction.z) * 180 / Math.PI;
            angle = angle + 90; // Rotate arrow 90 degrees to the right
            arrow.setAttribute('rotation', `0 ${angle} 0`);
          }

          console.log(`Arrow visible for ${objectType}, scale: ${scale.toFixed(2)}, input force: ${forceMagnitude}N`);
        } else {
          arrow.setAttribute('visible', false);
        }
      }
    });

    // 3D Physics Simulation Manager
    class PhysicsSimulation3D {
      constructor() {
        this.forceValue = 100;
        this.distanceValue = 5;
        // Delay initial display update to ensure DOM is ready
        setTimeout(() => {
          this.updateDisplays();
        }, 1000);
      }

      adjustForce(direction) {
        this.forceValue += direction * 10; // Changed from 25 to 10 for more precise control
        this.forceValue = Math.max(0, Math.min(1000, this.forceValue)); // Increased max to 1000
        this.updateDisplays();
        console.log('Force adjusted to:', this.forceValue);
      }

      adjustDistance(direction) {
        this.distanceValue += direction * 1;
        this.distanceValue = Math.max(1, Math.min(20, this.distanceValue));
        this.updateDisplays();
        console.log('Distance adjusted to:', this.distanceValue);
      }

      updateDisplays() {
        console.log('updateDisplays called, force:', this.forceValue, 'distance:', this.distanceValue);
        const forceDisplay = document.getElementById('force-display');
        const distanceDisplay = document.getElementById('distance-display');

        console.log('forceDisplay element found:', !!forceDisplay);
        console.log('distanceDisplay element found:', !!distanceDisplay);

        if (forceDisplay) {
          forceDisplay.setAttribute('value', this.forceValue.toString());
          console.log('Force display updated to:', this.forceValue);
        }
        if (distanceDisplay) {
          distanceDisplay.setAttribute('value', this.distanceValue.toString());
          console.log('Distance display updated to:', this.distanceValue);
        }
      }

      applyForce() {
        console.log(`Applying 3D force: ${this.forceValue}N, Distance: ${this.distanceValue}m`);

        // --- NPC ANIMATION ---
        const npc = document.getElementById('npc-puncher');
        if (npc) {
          console.log('NPC appearing and starting to walk.');
          npc.setAttribute('visible', true);
          npc.setAttribute('animation-mixer', {
            clip: 'Walk',
            loop: 'infinite' // Loop until car stops
          });
        }
        // --- END NPC ANIMATION ---

        // Physics objects removed - no action needed
      }

      reset() {
        console.log('Resetting 3D simulation...');

        const npcC = document.getElementById('npc-pusher');
        if (npcC) {
          npcC.setAttribute('visible', false);
        }
        const npcCart = document.getElementById('npc-pusher-cart');
        if (npcCart) {
          npcCart.setAttribute('visible', false);
        }

        // Reset car position
        const carGroup = document.getElementById('car-group');
        if (carGroup) {
          carGroup.setAttribute('position', '0 0 2');
        }

        // Reset cart position
        const cartGroup = document.getElementById('cart-group');
        if (cartGroup) {
          cartGroup.setAttribute('position', '3 0 3');
        }

        // Physics objects removed - no action needed
        setTimeout(() => {
          // Hide arrows
          const carArrow = document.getElementById('car-arrow');
          const cartArrow = document.getElementById('cart-arrow');
          if (carArrow) carArrow.setAttribute('visible', false);
          if (cartArrow) cartArrow.setAttribute('visible', false);

          // Reset 3D UI displays
          this.resetUI();
        }, 100);
      }

      resetUI() {
        requestAnimationFrame(() => {
          const elements = [
            { id: 'car-acceleration-3d', value: '0 m/s^2' },
            { id: 'car-velocity-3d', value: '0 m/s' },
            { id: 'car-distance-3d', value: '0 m' },
            { id: 'cart-acceleration-3d', value: '0 m/s^2' },
            { id: 'cart-velocity-3d', value: '0 m/s' },
            { id: 'cart-distance-3d', value: '0 m' }
          ];

          elements.forEach(item => {
            const element = document.getElementById(item.id);
            if (element) {
              element.setAttribute('value', item.value);
              console.log(`Reset 3D UI ${item.id} to ${item.value}`);
            }
          });
        });
      }
    }

    // Global variable for the 3D physics simulation
    let physicsSimulation3D;

    // Physics Simulation Manager (Legacy - keeping for compatibility)
    class PhysicsSimulation {
      constructor() {
        // This is now just a placeholder - all functionality moved to PhysicsSimulation3D
      }

      setupEventListeners() {
        // No longer needed as we use 3D interface
      }

      applyForce() {
        // Redirect to 3D version
        if (physicsSimulation3D) {
          physicsSimulation3D.applyForce();
        }
      }

      reset() {
        // Redirect to 3D version
        if (physicsSimulation3D) {
          physicsSimulation3D.reset();
        }
      }
    }

    // Initialize PhysicsSimulation3D immediately when script loads
    physicsSimulation3D = new PhysicsSimulation3D();
    console.log('PhysicsSimulation3D initialized immediately');

    // Debug: Log all elements with cursor-listener after scene loads
    document.addEventListener('DOMContentLoaded', function () {
      setTimeout(() => {
        const listenedElements = document.querySelectorAll('[cursor-listener]');
        console.log('Elements with cursor-listener:', listenedElements.length);
        listenedElements.forEach(el => {
          console.log('- Element:', el.id, 'has cursor-listener');
        });

        const clickableElements = document.querySelectorAll('.clickable');
        console.log('Clickable elements:', clickableElements.length);
        clickableElements.forEach(el => {
          console.log('- Clickable element:', el.id);
        });

        // Test physicsSimulation3D
        console.log('Testing physicsSimulation3D:', physicsSimulation3D);
        if (physicsSimulation3D) {
          console.log('physicsSimulation3D methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(physicsSimulation3D)));
        }

        // Physics panel buttons removed - no action needed

        // Debug cursor events
        const cursor = document.getElementById('main-cursor');
        if (cursor) {
          console.log('Found cursor, adding debug events');
          cursor.addEventListener('raycaster-intersection', function (evt) {
            console.log('Cursor intersecting with:', evt.detail.els.map(el => el.id));
          });
          cursor.addEventListener('raycaster-intersection-cleared', function (evt) {
            console.log('Cursor intersection cleared');
          });
          cursor.addEventListener('click', function (evt) {
            console.log('Cursor click event triggered');
          });
        }
      }, 2000); // Wait 2 seconds for A-Frame to fully initialize
    });

    // Panggil setupMobileControls saat DOM selesai dimuat
    document.addEventListener('DOMContentLoaded', function () {
      setupMobileControls();

      // Set default avatar (no selection needed)
        const rig = document.getElementById('rig');
        if (rig) {
        // Use default male avatar
        const modelUrl = 'https://cdn.glitch.global/c2231c1a-2935-4332-8715-032588334f99/Asian_M_1_Busi.glb?v=16813662';
          rig.setAttribute('player-info', 'avatarSrc', modelUrl);
      }
    });

    // Initialize mobile controls
    function setupMobileControls() {
      const camera = document.querySelector('[camera]');
      const rig = document.getElementById('rig');

      if (!camera) {
        console.error('Camera element not found');
        return;
      }

      const movementSpeed = 0.1;
      let isMobile = false;
      let joystick = null;

      // Initialize joystick
      function initJoystick() {
        // Remove any existing joystick
        if (joystick) {
          const joystickElement = document.getElementById('joystick');
          if (joystickElement) {
            joystickElement.innerHTML = '';
          }
        }

        joystick = new JoyStick('joystick', {
          title: 'joystick',
          width: 225,
          height: 225,
          internalFillColor: 'rgba(255, 255, 255, 0.5)',
          internalLineWidth: 2,
          internalStrokeColor: '#FFFFFF',
          externalLineWidth: 2,
          externalStrokeColor: 'rgba(255, 255, 255, 0.3)',
          autoReturnToCenter: true
        }, function (stickData) {
          if (stickData.x !== 0 || stickData.y !== 0) {
            // Invert Y-axis for natural movement (up = forward, down = backward)
            updateCameraMovement(stickData.x, -stickData.y);
          }
        });
      }

      // Update camera movement based on joystick input
      function updateCameraMovement(x, y) {
        if (!camera) return;

        const cameraEl = camera.object3D;
        const direction = new THREE.Vector3();
        cameraEl.getWorldDirection(direction);

        // Project direction onto XZ plane (ignore Y-axis for movement)
        const forward = new THREE.Vector3(direction.x, 0, direction.z).normalize();

        // Calculate movement vector based on joystick input
        const moveX = y * movementSpeed; // Positive X = right, Negative X = left
        const moveZ = x * movementSpeed; // Invert Y so positive Y = forward, negative Y = backward

        // Strafe movement (left/right) - use camera right vector
        const right = new THREE.Vector3();
        right.crossVectors(new THREE.Vector3(0, 1, 0), forward).normalize();

        // Calculate final movement direction
        const movement = new THREE.Vector3();
        // Forward/backward movement based on camera forward (positive Z is forward)
        movement.addScaledVector(forward, moveZ);
        // Left/right strafing (positive X is right)
        movement.addScaledVector(right, moveX);

        // Apply movement to camera position
        const currentPosition = camera.getAttribute('position');
        camera.setAttribute('position', {
          x: currentPosition.x + movement.x,
          y: currentPosition.y,  // Keep Y position the same (no flying)
          z: currentPosition.z + movement.z
        });
      }

      // Show joystick for mobile devices
      function checkDeviceType() {
        const deviceType = localStorage.getItem('deviceType');
        isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        console.log('Device type from localStorage:', deviceType);
        console.log('Is mobile device:', isMobile);

        // Show joystick if:
        // 1. User selected 'mobile' in localStorage, OR
        // 2. Device is detected as mobile (regardless of localStorage)
        if (deviceType === 'mobile' || isMobile) {
          console.log('Showing joystick for mobile device');
          document.getElementById('mobile-controls').style.display = 'block';
          initJoystick();
        } else {
          console.log('Hiding joystick for desktop');
          document.getElementById('mobile-controls').style.display = 'none';
        }
      }

      // Initialize mobile controls
      checkDeviceType();
    }

    // Animation loop for smooth movement
    function animate() {
      requestAnimationFrame(animate);
    }

    // Setup video element (but don't play it yet)
    function setupVideo() {
      const videoEl = document.querySelector('#excretoryVideo');
      const videoEntity = document.querySelector('#whiteScreenVideo');
      
      if (!videoEl) {
        console.error('Video element #excretoryVideo not found');
        return;
      }
      
      if (!videoEntity) {
        console.error('Video entity #whiteScreenVideo not found');
        return;
      }

      // Set video source explicitly to handle special characters
      const videoPath = 'assets/video/EXCRETORY SYSTEM üßçüèª_‚ôÇÔ∏è Urinary System and Sweat Glands üß¨ Science for Kids.mp4';
      const sourceEl = videoEl.querySelector('source');
      if (sourceEl) {
        sourceEl.src = videoPath;
      } else {
        videoEl.src = videoPath;
      }

      // Don't load or play video yet - wait for button click
      // Video will be loaded and played when "Mulai Observasi" button is clicked
      
      console.log('Video element initialized (not loaded yet)');
      
      // Only handle errors
      videoEl.addEventListener('error', function(e) {
        console.error('Video load error:', e);
        console.error('Video error code:', videoEl.error ? videoEl.error.code : 'unknown');
        console.error('Video src:', videoEl.src);
        console.error('Video currentSrc:', videoEl.currentSrc);
    });
    }

    // Setup video controls (play/pause, seekbar)
    function setupVideoControls() {
      let currentVideoEl = document.querySelector('#excretoryVideo'); // Start with video 1
      const playPauseBtn = document.getElementById('playPauseBtn');
      const seekContainer = document.getElementById('seekContainer');
      const seekBar = document.getElementById('seekBar');
      const seekHandle = document.getElementById('seekHandle');
      const videoTime = document.getElementById('videoTime');
      const videoControls = document.getElementById('videoControls');
      const nextVideoBtn = document.getElementById('nextVideoBtn');
      const videoEntity = document.querySelector('#whiteScreenVideo');

      if (!currentVideoEl || !playPauseBtn || !seekContainer || !seekBar || !seekHandle || !videoTime || !videoControls || !nextVideoBtn || !videoEntity) {
        console.error('Video controls elements not found');
        return;
      }

      let isDragging = false;
      let currentVideoIndex = 1; // 1 = excretoryVideo, 2 = bodyOdorVideo

      // Format time (seconds to MM:SS)
      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      }

      // Update video controls UI
      function updateControls() {
        if (!currentVideoEl || !currentVideoEl.duration) return;

        const currentTime = currentVideoEl.currentTime;
        const duration = currentVideoEl.duration;
        const percent = (currentTime / duration) * 100;

        // Update seekbar
        seekBar.style.width = percent + '%';
        seekHandle.style.left = percent + '%';

        // Update time display
        videoTime.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;

        // Update play/pause button
        if (currentVideoEl.paused) {
          playPauseBtn.textContent = '‚ñ∂';
        } else {
          playPauseBtn.textContent = '‚è∏';
        }
      }

      // Play/Pause button
      playPauseBtn.addEventListener('click', function() {
        if (currentVideoEl.paused) {
          currentVideoEl.play().catch(err => console.log('Play error:', err));
        } else {
          currentVideoEl.pause();
        }
      });

      // Seekbar click
      seekContainer.addEventListener('click', function(e) {
        if (isDragging || !currentVideoEl.duration) return;
        const rect = seekContainer.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        const newTime = percent * currentVideoEl.duration;
        currentVideoEl.currentTime = newTime;
      });

      // Seekbar drag
      seekHandle.addEventListener('mousedown', function(e) {
        isDragging = true;
        e.preventDefault();
      });

      document.addEventListener('mousemove', function(e) {
        if (!isDragging || !currentVideoEl.duration) return;
        const rect = seekContainer.getBoundingClientRect();
        let percent = (e.clientX - rect.left) / rect.width;
        percent = Math.max(0, Math.min(1, percent)); // Clamp between 0 and 1
        const newTime = percent * currentVideoEl.duration;
        currentVideoEl.currentTime = newTime;
      });

      document.addEventListener('mouseup', function() {
        isDragging = false;
      });

      // Touch support for mobile
      seekHandle.addEventListener('touchstart', function(e) {
        isDragging = true;
        e.preventDefault();
      });

      document.addEventListener('touchmove', function(e) {
        if (!isDragging || !currentVideoEl.duration) return;
        const rect = seekContainer.getBoundingClientRect();
        const touch = e.touches[0];
        let percent = (touch.clientX - rect.left) / rect.width;
        percent = Math.max(0, Math.min(1, percent));
        const newTime = percent * currentVideoEl.duration;
        currentVideoEl.currentTime = newTime;
      });

      document.addEventListener('touchend', function() {
        isDragging = false;
      });

      // Update controls on video events
      function attachVideoEvents(videoElement) {
        videoElement.addEventListener('timeupdate', updateControls);
        videoElement.addEventListener('loadedmetadata', updateControls);
        videoElement.addEventListener('play', updateControls);
        videoElement.addEventListener('pause', updateControls);
        videoElement.addEventListener('ended', function() {
          // Show Next button when video 1 ends
          if (currentVideoIndex === 1) {
            nextVideoBtn.classList.add('show');
          }
          // Show Finish button when video 2 ends
          if (currentVideoIndex === 2) {
            const finishBtn = document.getElementById('finishBtn');
            if (finishBtn) {
              finishBtn.classList.add('show');
            }
          }
        });
      }

      // Attach events to initial video
      attachVideoEvents(currentVideoEl);

      // Next Video Button Handler
      nextVideoBtn.addEventListener('click', function() {
        if (currentVideoIndex === 1) {
          // Switch to video 2
          const bodyOdorVideo = document.querySelector('#bodyOdorVideo');
          if (!bodyOdorVideo) {
            console.error('Video 2 (bodyOdorVideo) not found');
            return;
          }

          // Hide Next button
          nextVideoBtn.classList.remove('show');

          // Remove old video events
          currentVideoEl.removeEventListener('timeupdate', updateControls);
          currentVideoEl.removeEventListener('loadedmetadata', updateControls);
          currentVideoEl.removeEventListener('play', updateControls);
          currentVideoEl.removeEventListener('pause', updateControls);

          // Pause and reset old video
          currentVideoEl.pause();
          currentVideoEl.currentTime = 0;

          // Switch to new video
          currentVideoEl = bodyOdorVideo;
          currentVideoIndex = 2;

          // Update video entity source
          videoEntity.setAttribute('src', '#bodyOdorVideo');

          // Load and play new video
          if (bodyOdorVideo.readyState === 0) {
            bodyOdorVideo.load();
          }

          // Attach events to new video
          attachVideoEvents(bodyOdorVideo);

          // Play new video
          bodyOdorVideo.play().catch(err => {
            console.log('Video 2 play error:', err);
            document.addEventListener('click', () => {
              bodyOdorVideo.play().catch(e => console.log('Video 2 play retry error:', e));
            }, { once: true });
          });

          console.log('Switched to Video 2');
        }
      });

      // Finish Button Handler
      const finishBtn = document.getElementById('finishBtn');
      const finalQuestionPopup = document.getElementById('finalQuestionPopup');
      
      if (finishBtn && finalQuestionPopup) {
        finishBtn.addEventListener('click', function() {
          // Hide finish button
          finishBtn.classList.remove('show');
          
          // Show final question popup
        setTimeout(() => {
            finalQuestionPopup.classList.add('show');
            
            // Hide popup after 7 seconds and show Done button
            setTimeout(() => {
              finalQuestionPopup.classList.remove('show');
              finalQuestionPopup.classList.add('hide');
              
              // Show Done button after popup fades out
              setTimeout(() => {
                const doneBtn = document.getElementById('doneBtn');
                if (doneBtn) {
                  doneBtn.classList.add('show');
                }
              }, 800); // Wait for fade out animation
            }, 7000); // 7 seconds
          }, 500);
        });
    }

      // Done Button Handler - Transition to Lab Biologi
      const doneBtn = document.getElementById('doneBtn');
      if (doneBtn) {
        doneBtn.addEventListener('click', function() {
          // Hide done button
          doneBtn.classList.remove('show');
          
          // Hide all video and observation related elements
          const videoControls = document.getElementById('videoControls');
          const nextVideoBtn = document.getElementById('nextVideoBtn');
          const finishBtn = document.getElementById('finishBtn');
          const videoEntity = document.querySelector('#whiteScreenVideo');
          const keringatImage = document.querySelector('#keringatImageEntity');
          const kulitImage = document.querySelector('#kulitImageEntity');
          const kulit2Image = document.querySelector('#kulit2ImageEntity');
          const questionPopup = document.getElementById('questionPopup');
          const explanationText = document.getElementById('explanationText');
          const startBtn = document.getElementById('startObservationBtn');
          const finalQuestionPopup = document.getElementById('finalQuestionPopup');
          
          // Hide video controls
          if (videoControls) {
            videoControls.classList.remove('show');
            videoControls.style.display = 'none';
          }
          
          // Hide buttons
          if (nextVideoBtn) nextVideoBtn.classList.remove('show');
          if (finishBtn) finishBtn.classList.remove('show');
          if (startBtn) startBtn.classList.remove('show');
          
          // Hide popups
          if (questionPopup) {
            questionPopup.classList.remove('show');
            questionPopup.classList.add('hide');
          }
          if (explanationText) {
            explanationText.classList.remove('show');
            explanationText.classList.add('hide');
          }
          if (finalQuestionPopup) {
            finalQuestionPopup.classList.remove('show');
            finalQuestionPopup.classList.add('hide');
          }
          
          // Hide video and images
          if (videoEntity) videoEntity.setAttribute('visible', 'false');
          if (keringatImage) keringatImage.setAttribute('visible', 'false');
          if (kulitImage) kulitImage.setAttribute('visible', 'false');
          if (kulit2Image) kulit2Image.setAttribute('visible', 'false');
          
          // Pause all videos
          const excretoryVideo = document.querySelector('#excretoryVideo');
          const bodyOdorVideo = document.querySelector('#bodyOdorVideo');
          if (excretoryVideo) {
            excretoryVideo.pause();
            excretoryVideo.currentTime = 0;
          }
          if (bodyOdorVideo) {
            bodyOdorVideo.pause();
            bodyOdorVideo.currentTime = 0;
          }
          
          // Redirect to Scene 1 Bab 2 page
          window.location.href = 'scene1-bab2.html';
        });
      }
    }

    // Setup interactive flow for Virtual Lab
    function setupInteractiveFlow() {
      const questionPopup = document.getElementById('questionPopup');
      const explanationText = document.getElementById('explanationText');
      const startBtn = document.getElementById('startObservationBtn');
      const videoEntity = document.querySelector('#whiteScreenVideo');

      // Step 1: Show question popup when scene loads
      const scene = document.querySelector('a-scene');
      if (scene) {
        if (scene.hasLoaded) {
          startFlow();
        } else {
          scene.addEventListener('loaded', startFlow);
        }
      }

      function startFlow() {
        // Show question popup
        setTimeout(() => {
          questionPopup.classList.add('show');
        }, 500); // Small delay for smooth appearance

        // Step 2: Hide question popup after 10 seconds with smooth animation
        setTimeout(() => {
          questionPopup.classList.remove('show');
          questionPopup.classList.add('hide');
          
          // Step 3: Show explanation text after popup fades out
          setTimeout(() => {
            explanationText.classList.add('show');
            
            // Step 4: Hide explanation text after 7 seconds
            setTimeout(() => {
              explanationText.classList.remove('show');
              explanationText.classList.add('hide');

              // Step 5: Show "Mulai Observasi" button
            setTimeout(() => {
                startBtn.classList.add('show');
              }, 800); // Wait for fade out animation
            }, 7000);
          }, 800); // Wait for fade out animation
        }, 10000); // 10 seconds for question popup
      }

      // Step 6: Handle button click to show video and images
      startBtn.addEventListener('click', function() {
        // Hide button with fade out
        startBtn.classList.remove('show');
        
        // Show video and images after button fades out
        setTimeout(() => {
          const videoEl = document.querySelector('#excretoryVideo');
          const videoControls = document.getElementById('videoControls');
          const keringatImage = document.querySelector('#keringatImageEntity');
          const kulitImage = document.querySelector('#kulitImageEntity');
          const kulit2Image = document.querySelector('#kulit2ImageEntity');
          
          if (videoEntity && videoEl) {
            // Load video first (if not already loaded)
            if (videoEl.readyState === 0) {
              videoEl.load();
            }
            
            // Make video visible
            videoEntity.setAttribute('visible', 'true');
            
            // Make images visible
            if (keringatImage) {
              console.log('Keringat image found, making visible:', keringatImage);
              keringatImage.setAttribute('visible', 'true');
              console.log('Keringat image position:', keringatImage.getAttribute('position'));
            } else {
              console.error('Keringat image element not found!');
            }
            if (kulitImage) {
              console.log('Kulit image found, making visible:', kulitImage);
              kulitImage.setAttribute('visible', 'true');
              console.log('Kulit image position:', kulitImage.getAttribute('position'));
            } else {
              console.error('Kulit image element not found!');
            }
            if (kulit2Image) {
              console.log('Kulit2 image found, making visible:', kulit2Image);
              kulit2Image.setAttribute('visible', 'true');
              console.log('Kulit2 image position:', kulit2Image.getAttribute('position'));
            } else {
              console.error('Kulit2 image element not found!');
            }
            
            // Show video controls
            if (videoControls) {
              videoControls.classList.add('show');
            }
            
            // Fade in video using material opacity
            videoEntity.setAttribute('material', {
              side: 'double',
              shader: 'flat',
              opacity: 0
            });
            
            // Fade in images using material opacity
            if (keringatImage) {
              keringatImage.setAttribute('material', {
                side: 'double',
                shader: 'flat',
                opacity: 0
              });
          }
            if (kulitImage) {
              kulitImage.setAttribute('material', {
                side: 'double',
                shader: 'flat',
                opacity: 0
              });
            }
            if (kulit2Image) {
              kulit2Image.setAttribute('material', {
                side: 'double',
                shader: 'flat',
                opacity: 0
              });
            }
            
            // Wait for video to be ready, then play
            const playVideo = () => {
              videoEl.play().catch(err => {
                console.log('Video play error:', err);
                // If autoplay is blocked, try again after user interaction
                document.addEventListener('click', () => {
                  videoEl.play().catch(e => console.log('Video play retry error:', e));
                }, { once: true });
              });
            };
            
            if (videoEl.readyState >= 2) {
              // Video is already loaded, play immediately
              playVideo();
            } else {
              // Wait for video to load
              videoEl.addEventListener('canplay', playVideo, { once: true });
            }
            
            // Animate opacity to 1 for video and images
            let opacity = 0;
            const fadeInterval = setInterval(() => {
              opacity += 0.05;
              if (opacity >= 1) {
                opacity = 1;
                clearInterval(fadeInterval);
              }
              videoEntity.setAttribute('material', {
                side: 'double',
                shader: 'flat',
                opacity: opacity
              });
              if (keringatImage) {
                keringatImage.setAttribute('material', {
                  side: 'double',
                  shader: 'flat',
                  opacity: opacity
                });
              }
              if (kulitImage) {
                kulitImage.setAttribute('material', {
                  side: 'double',
                  shader: 'flat',
                  opacity: opacity
                });
              }
              if (kulit2Image) {
                kulit2Image.setAttribute('material', {
                  side: 'double',
                  shader: 'flat',
                  opacity: opacity
                });
              }
            }, 30);
          }

          console.log('Observasi dimulai - Video dan gambar akan ditampilkan');
        }, 800); // Wait for button fade out
      });
    }

    // Prevent avatar selection modal from appearing
    function hideAvatarSelection() {
      // Hide avatar selection modals immediately
      const observer = new MutationObserver(() => {
        const avatarModals = document.querySelectorAll('div[class*="naf-centered-fullscreen"], div[class*="avatar-selection"], div[id*="avatar"], .avatar-modal, .avatar-selection-modal');
        avatarModals.forEach(modal => {
          if (modal.textContent.includes('Pilih Avatar') || 
              modal.textContent.includes('Avatar') || 
              modal.textContent.includes('Your avatar') ||
              modal.textContent.includes('Gender') ||
              modal.textContent.includes('Outfit')) {
            modal.style.display = 'none';
            modal.style.visibility = 'hidden';
            modal.remove();
          }
        });
      });

      observer.observe(document.body, {
        childList: true,
        subtree: true
      });

      // Also hide any existing modals
      setTimeout(() => {
        const avatarModals = document.querySelectorAll('div[class*="naf-centered-fullscreen"], div[class*="avatar-selection"], div[id*="avatar"], .avatar-modal, .avatar-selection-modal');
        avatarModals.forEach(modal => {
          modal.style.display = 'none';
          modal.style.visibility = 'hidden';
          modal.remove();
        });
      }, 100);
    }

    // Start the application
    document.addEventListener('DOMContentLoaded', function () {
      hideAvatarSelection();
      setupMobileControls();
      setupVideo();
      setupVideoControls();
      setupInteractiveFlow();
      animate();
    });
  </script>
</body>

</html>