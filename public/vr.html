<!doctype html>
<html lang="id">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BioExplore</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet" />
    
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.min.js"></script>
    <script src="https://unpkg.com/networked-aframe@0.14.0/dist/networked-aframe.min.js"></script>
    <script src="https://unpkg.com/networked-aframe@0.14.0/dist/easyrtc-adapter.js"></script>
    <script>
      // Global configuration - moved after EasyRTC loads
      window.NAF_OPTIONS = {
        updateRate: 15, // Update rate in Hz
        useLerp: true,
        useHttps: window.location.protocol === 'https:',
        debug: true,
      };

      // ICE servers configuration
      const iceServers = [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
      ];

      // Initialize EasyRTC with proper configuration - only after scripts load
      document.addEventListener('DOMContentLoaded', function() {
        if (typeof easyrtc !== 'undefined') {
          easyrtc.enableDebug(false);
          easyrtc.setStunServers(iceServers);
          easyrtc.enableVideo(false);
          easyrtc.enableAudio(false);
          easyrtc.enableDataChannels(true);
        } else {
          console.warn('EasyRTC not loaded, networking features may not work');
        }
      });
    </script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.6.0/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-environment-component@1.5.0/dist/aframe-environment-component.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-gltf-model-plus@1.0.0/dist/gltf-model-plus.min.js"></script>
    <script src="/js/joystick.js"></script>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap');

      /* Reset and Base Styles */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        transition:
          all 0.3s ease,
          transform 0.2s ease;
      }

      body {
        font-family: 'Orbitron', sans-serif;
        background: #0a0a1a;
        color: #fff;
        min-height: 100vh;
        overflow: hidden;
        position: relative;
      }

      /* Particle Background */
      #particles-js {
        position: absolute;
        width: 100%;
        height: 100%;
        z-index: 0;
      }

      /* Main Container */
      .main-container {
        position: relative;
        z-index: 1;
        height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        padding: 2rem;
        opacity: 0;
        animation: fadeIn 1s ease-out forwards;
      }

      /* Logo */
      .logo {
        font-size: 4rem;
        font-weight: 700;
        margin-bottom: 1rem;
        background: linear-gradient(90deg, var(--neon-blue), var(--neon-cyan));
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: var(--text-glow);
        letter-spacing: 2px;
      }

      /* Tagline */
      .tagline {
        font-size: 1.2rem;
        margin-bottom: 3rem;
        color: rgba(255, 255, 255, 0.8);
        letter-spacing: 1px;
      }

      /* Start Button */
      .start-btn {
        background: transparent;
        color: var(--neon-cyan);
        border: 2px solid var(--neon-cyan);
        padding: 1rem 3rem;
        font-size: 1.2rem;
        font-weight: bold;
        border-radius: 50px;
        cursor: pointer;
        position: relative;
        overflow: hidden;
        z-index: 1;
        text-transform: uppercase;
        letter-spacing: 2px;
        box-shadow: 0 0 15px rgba(0, 255, 234, 0.3);
        transition: all 0.3s ease;
      }

      .start-btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(0, 255, 234, 0.2), transparent);
        transition: 0.5s;
        z-index: -1;
      }

      .start-btn:hover {
        color: #fff;
        box-shadow: 0 0 25px var(--neon-cyan);
        text-shadow: 0 0 10px #fff;
      }

      .start-btn:hover::before {
        left: 100%;
      }

      /* Animations */
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes float {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-10px);
        }
      }

      .floating {
        animation: float 3s ease-in-out infinite;
      }

      /* Add focus styles for accessibility */
      .selection-card:focus {
        outline: 3px solid #3a7bd5;
        outline-offset: 3px;
      }

      /* Add subtle hover effect on buttons */
      button {
        transition: all 0.2s ease;
      }

      button:active {
        transform: scale(0.95);
      }

      .ui-buttons {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 10000;
        display: flex;
        gap: 10px;
      }

      .ui-button {
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: 1px solid #3a7bd5;
        border-radius: 20px;
        padding: 8px 16px;
        font-size: 14px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.3s ease;
      }

      .ui-button:hover {
        background: rgba(58, 123, 213, 0.9);
      }

      .ui-button i {
        font-size: 16px;
      }

      /* VR Button - Hidden */
      .a-enter-vr-button {
        display: none !important;
      }

      #custom-vr-btn {
        display: none !important;
      }
    </style>
    <script>
      // Global variables
      let mobileControls;
      let joystick = null;
      
      // Initialize particle animation
      function initParticles() {
        const canvas = document.createElement('canvas');
        canvas.id = 'particles-canvas';
        canvas.classList.add('particles');
        document.body.appendChild(canvas);

        const ctx = canvas.getContext('2d');

        // Set canvas size
        function resizeCanvas() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Particle class
        class Particle {
          constructor() {
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.size = Math.random() * 2 + 0.5;
            this.speedX = Math.random() * 1 - 0.5;
            this.speedY = Math.random() * 1 - 0.5;
            this.color = `rgba(0, 247, 255, ${Math.random() * 0.5 + 0.1})`;
          }

          update() {
            this.x += this.speedX;
            this.y += this.speedY;

            if (this.x < 0 || this.x > canvas.width) this.speedX *= -1;
            if (this.y < 0 || this.y > canvas.height) this.speedY *= -1;
          }

          draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // Create particles
        const particles = [];
        for (let i = 0; i < 100; i++) {
          particles.push(new Particle());
        }

        // Animation loop
        function animate() {
          ctx.fillStyle = 'rgba(10, 10, 26, 0.1)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          for (let i = 0; i < particles.length; i++) {
            particles[i].update();
            particles[i].draw();

            // Connect particles
            for (let j = i; j < particles.length; j++) {
              const dx = particles[i].x - particles[j].x;
              const dy = particles[i].y - particles[j].y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance < 100) {
                ctx.strokeStyle = `rgba(0, 247, 255, ${1 - distance / 100})`;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(particles[i].x, particles[i].y);
                ctx.lineTo(particles[j].x, particles[j].y);
                ctx.stroke();
              }
            }
          }

          requestAnimationFrame(animate);
        }

        animate();
      }

      // Initialize everything when DOM is loaded
      document.addEventListener('DOMContentLoaded', () => {
        initParticles();
        
        // Initialize mobile controls reference
        mobileControls = document.getElementById('mobile-controls');
        
        // Show device selection immediately
        document.getElementById('device-selection').style.display = 'flex';
        // Setup mobile controls
        setupMobileControls();
        // Start with desktop experience by default
        initializeExperience('desktop');
      });
      
      // Initialize mobile controls
      function setupMobileControls() {
        const camera = document.querySelector('[camera]');
        const rig = document.getElementById('rig');

        if (!camera) {
          console.error('Camera element not found');
          return;
        }

        let joystick = null;
        const movementSpeed = 0.1;
        let isMobile = false;

        // Initialize joystick
        function initJoystick() {
          joystick = new JoyStick('joystick', {
            title: 'joystick',
            width: 150,
            height: 150,
            internalFillColor: 'rgba(255, 255, 255, 0.5)',
            internalLineWidth: 2,
            internalStrokeColor: '#FFFFFF',
            externalLineWidth: 2,
            externalStrokeColor: 'rgba(255, 255, 255, 0.3)',
            autoReturnToCenter: true
          }, function (stickData) {
            if (stickData.x !== 0 || stickData.y !== 0) {
              updateCameraMovement(stickData.x, stickData.y);
            }
          });
        }

        // Update camera movement based on joystick input
        function updateCameraMovement(x, y) {
          if (!camera) return;

          const cameraEl = camera.object3D;
          const direction = new THREE.Vector3();
          cameraEl.getWorldDirection(direction);

          // Project direction onto XZ plane (ignore Y-axis for movement)
          const forward = new THREE.Vector3(direction.x, 0, direction.z).normalize();

          // Calculate movement vector based on joystick input (no inversion for Y-axis)
          const moveX = x * movementSpeed;
          const moveZ = y * movementSpeed;

          // Strafe movement (left/right) - use camera right vector
          const right = new THREE.Vector3();
          right.crossVectors(new THREE.Vector3(0, 1, 0), forward).normalize();

          // Calculate final movement direction
          const movement = new THREE.Vector3();
          // Forward/backward movement based on camera forward (positive Z is forward)
          movement.addScaledVector(forward, moveZ);
          // Left/right strafing (positive X is right)
          movement.addScaledVector(right, moveX);

          // Apply movement to camera position
          const currentPosition = camera.getAttribute('position');
          camera.setAttribute('position', {
            x: currentPosition.x + movement.x,
            y: currentPosition.y,  // Keep Y position the same (no flying)
            z: currentPosition.z + movement.z
          });
        }

        // Show joystick for mobile devices
        function checkDeviceType() {
          const deviceType = localStorage.getItem('deviceType');
          isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

          console.log('Device type from localStorage:', deviceType);
          console.log('Is mobile device:', isMobile);

          // Show joystick if:
          // 1. User selected 'mobile' in localStorage, OR
          // 2. Device is detected as mobile (regardless of localStorage)
          if (deviceType === 'mobile' || isMobile) {
            console.log('Showing joystick for mobile device');
            document.getElementById('mobile-controls').style.display = 'block';
            initJoystick();
          } else {
            console.log('Hiding joystick for desktop');
            document.getElementById('mobile-controls').style.display = 'none';
          }
        }

        // Initialize mobile controls
        checkDeviceType();
        
        // Start animation loop for smooth movement
        function animate() {
          requestAnimationFrame(animate);
        }
        animate();

        // Expose function to initialize joystick when mobile mode is selected
        window.initJoystick = initJoystick;
      }

      window.uiSettings = {
        showRandomAvatarButton: false,
        showDieButton: true,
      };

      // Device Toggle Functionality
      function setupDeviceToggle() {
        const deviceToggle = document.getElementById('device-toggle');
        const mobileControls = document.getElementById('mobile-controls');

        // Update UI based on current device mode
        function updateDeviceUI() {
          const currentMode = localStorage.getItem('deviceType') || 'desktop';
          if (deviceToggle) {
            let icon, text;
            switch (currentMode) {
              case 'mobile':
                icon = 'üì±';
                text = 'Switch to Desktop';
                // Show mobile controls when in mobile mode
                if (mobileControls) {
                  mobileControls.style.display = 'block';
                  // Initialize joystick if not already initialized
                  if (window.initJoystick) {
                    window.initJoystick();
                  }
                }
                break;
              default: // desktop
                icon = 'üñ•Ô∏è';
                text = 'Switch to Mobile';
                // Hide mobile controls in desktop mode
                if (mobileControls) mobileControls.style.display = 'none';
            }
            deviceToggle.innerHTML = `<i>${icon}</i><span>${text}</span>`;
          }
        }

        // Toggle between device modes
        function toggleDeviceMode() {
          const currentMode = localStorage.getItem('deviceType') || 'desktop';
          let newMode;

          // Cycle through modes: desktop <-> mobile
          switch (currentMode) {
            case 'desktop':
              newMode = 'mobile';
              break;
            case 'mobile':
            default:
              newMode = 'desktop';
          }

          localStorage.setItem('deviceType', newMode);
          updateDeviceUI();

          // Reinitialize controls if needed
          if (newMode === 'mobile' && mobileControls) {
            mobileControls.style.display = 'block';
            if (typeof setupMobileControls === 'function') {
              setupMobileControls();
            }
          } else if (mobileControls) {
            mobileControls.style.display = 'none';
          }
        }

        // Initialize the button
        if (deviceToggle) {
          deviceToggle.addEventListener('click', toggleDeviceMode);
          updateDeviceUI();
        }
      }

      // Initialize when DOM is loaded
      document.addEventListener('DOMContentLoaded', function () {
        setupDeviceToggle();

        // Initialize Networked-Aframe after a short delay to ensure all scripts are loaded
        setTimeout(() => {
          if (window.NAF && window.easyrtc) {
            initializeNetworkedAFrame();
          } else if (window.NAF) {
            // NAF is loaded but EasyRTC might not be, try without networking
            console.warn('EasyRTC not loaded, running without networking');
            initNetworkedAFrame();
          } else {
            console.error('Required libraries not loaded');
          }
        }, 1000);
      });
    </script>
    <script src="/dist/components.js"></script>
    <script src="/js/joystick.js"></script>
    <script defer src="/dist/ui.js"></script>

    <!-- UI Buttons Container -->
    <div class="ui-buttons">
      <!-- Random Avatar Button (will be shown by UI system) -->
      <!-- Device Toggle Button -->
      <button id="device-toggle" class="ui-button">
        <i>üì±</i>
        <span>Switch to Mobile</span>
      </button>
    </div>
  </head>

  <body class="fade-in">

    <!-- Particle Background -->
    <div id="particles-js"></div>
    
    <!-- Mobile Controls -->
    <div id="mobile-controls" style="position: fixed; bottom: 30px; left: 20px; z-index: 1000; display: none; touch-action: none; -webkit-tap-highlight-color: transparent;">
      <!-- Joystick Control -->
      <div id="joystick" style="width: 150px; height: 150px; background: rgba(255, 255, 255, 0.2); border-radius: 50%; position: relative; overflow: visible;">
        <div id="joystick-knob" style="width: 80px; height: 80px; background: rgba(255, 255, 255, 0.5); border-radius: 50%; position: absolute; left: 35px; top: 35px; transition: transform 0.1s ease-out; touch-action: none; pointer-events: none;"></div>
      </div>
    </div>

    <!-- Device Selection Screen -->
    <div id="device-selection" class="selection-screen">
      <div class="selection-container">
        <h1 class="selection-title">Pilih Perangkat Anda</h1>
        <div class="selection-grid">
          <div class="selection-card" id="btn-desktop">
            <div class="card-icon">üíª</div>
            <h3>Desktop</h3>
            <p>Gunakan keyboard dan mouse</p>
          </div>
          <div class="selection-card highlight" id="btn-mobile">
            <div class="card-icon">üì±</div>
            <h3>Mobile</h3>
            <p>Kontrol dengan layar sentuh</p>
            <span class="badge">Rekomendasi</span>
          </div>
        </div>
      </div>
    </div>

    <style>
      .selection-screen {
        position: fixed;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }

      .selection-container {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 2.5rem 3rem;
        max-width: 900px;
        width: 90%;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
        text-align: center;
      }

      .selection-title {
        color: #fff;
        font-size: 2.5em;
        margin-bottom: 2rem;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        background: linear-gradient(90deg, #fff, #b8c6db);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      .selection-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 1.5rem;
        margin-top: 2rem;
      }

      .selection-card {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 15px;
        padding: 2rem;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        border: 2px solid transparent;
      }

      .selection-card:hover {
        transform: translateY(-10px);
        box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
        border-color: #3a7bd5;
      }

      .selection-card.highlight {
        border: 2px solid #9c27b0;
        position: relative;
      }

      .selection-card.highlight::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(90deg, #9c27b0, #e91e63);
      }

      .card-icon {
        font-size: 3.5rem;
        margin-bottom: 1rem;
        transition: transform 0.3s ease;
      }

      .selection-card:hover .card-icon {
        transform: scale(1.2);
      }

      .selection-card h3 {
        color: #333;
        margin: 0.5rem 0;
        font-size: 1.4rem;
      }

      .selection-card p {
        color: #666;
        font-size: 0.9rem;
        margin: 0.5rem 0 0;
      }

      .badge {
        position: absolute;
        top: 10px;
        right: -25px;
        background: #9c27b0;
        color: white;
        padding: 2px 25px;
        font-size: 0.7rem;
        transform: rotate(45deg);
        width: 100px;
        text-align: center;
      }

      @media (max-width: 768px) {
        .selection-grid {
          grid-template-columns: 1fr;
        }

        .selection-container {
          padding: 1.5rem;
          margin: 1rem;
          width: auto;
        }

        .selection-title {
          font-size: 2rem;
        }
      }

      /* Hide avatar selection modal */
      div[class*="naf-centered-fullscreen"],
      div[class*="avatar-selection"],
      div[id*="avatar"],
      .avatar-modal,
      .avatar-selection-modal {
        display: none !important;
        visibility: hidden !important;
      }
    </style>

    <!-- Virtual Gamepad for Mobile -->
    <div
      id="mobile-controls"
      style="
        position: fixed;
        bottom: 30px;
        left: 20px;
        z-index: 1000;
        display: none;
        touch-action: none;
        -webkit-tap-highlight-color: transparent;
      "
    >
      <!-- Joystick Control -->
      <div
        id="joystick"
        style="
          width: 180px;
          height: 180px;
          background: rgba(255, 255, 255, 0.2);
          border-radius: 50%;
          position: relative;
          overflow: visible;
        "
      >
        <div
          id="joystick-knob"
          style="
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            left: 30px;
            top: 30px;
            transition: transform 0.1s ease-out;
            touch-action: none;
            pointer-events: none;
          "
        ></div>
      </div>
    </div>

    <!-- Hidden A-Frame scene (will be shown when needed) -->
    <a-scene
      style="display: none"
      light="defaultLightsEnabled:false"
      renderer="stencil:true; antialias: true;"
      vr-mode-ui="enabled: false"
      webxr="requiredFeatures: local-floor; referenceSpaceType: local-floor;"
      networked-scene="
        connectOnLoad: false;
        room: lobby;
        debug: true;
        adapter: easyrtc;
        audio: false;
        onConnect: onConnect;
        video: false;"
      shadow="type: pcfsoft"
      gltf-model="meshoptDecoderPath:https://unpkg.com/meshoptimizer@0.19.0/meshopt_decoder.js"
      raycaster="far: 100; objects: .clickable, .portal, .portal-click;"
      cursor="rayOrigin: mouse; fuse: false"
    >
      <a-assets>
        <img id="thumbScene1" crossorigin="anonymous" src="https://cdn.aframe.io/link-traversal/thumbs/forest.png" />
        <a-asset-item id="avatar-male-model" src="SittingIdle_man.fbx"></a-asset-item>
        <a-asset-item id="avatar-female-model" src="SittingIdle_woman.fbx"></a-asset-item>
        <template id="avatar-template">
          <a-entity player-info>
            <a-entity class="model" animation-mixer>
              <a-text class="nametag" align="center" value="?" position="0 2.1 0" scale=".5 .5 .5"></a-text>
            </a-entity>
            <a-entity class="camera" position="0 1.6 0"></a-entity>
          </a-entity>
        </template>
      </a-assets>

      <a-gltf-model id="world-nav-mesh" src="assets/home/world.glb" nav-mesh class="collidable"></a-gltf-model>

      <a-text
        value="BioExplore"
        align="center"
        position="0 2.5 -4"
        scale="2 2 2"
        color="#4CC3D9"
        style="font-weight: bold"
      ></a-text>
      <a-text
        value="Biology Exploration Virtual Reality"
        align="center"
        position="0 2 -4"
        scale="2 2 2"
        style="font-weight: bold"
      ></a-text>

      <!-- Portal 1: World 1 -->
      <a-entity
        id="portal-1"
        position="3 1.6 -10"
        class="clickable portal"
        data-scene="scene1.html"
        data-room="scene1"
      >
        <a-circle
          geometry="radius: 1.2"
          material="src: #thumbScene1; shader: flat; side: double"
          class="clickable portal-click"
          data-scene="scene1.html"
          data-room="scene1"
          event-set__mouseenter="material.opacity: 0.8"
          event-set__mouseleave="material.opacity: 1"
        ></a-circle>
        <a-ring
          geometry="radiusInner: 1.15; radiusOuter: 1.3"
          material="color: #4CC3D9; shader: flat; side: double; transparent: true; opacity: 0.6"
        ></a-ring>
        <a-text
          value="Go To World 1"
          position="0 1.5 0"
          align="center"
          color="#fff"
          scale="2 2 2"
        ></a-text>
      </a-entity>

      <!-- Portal 2: World 2 -->
      <a-entity
        id="portal-2"
        position="-3 1.6 -10"
        class="clickable portal"
        data-scene="scene2.html"
        data-room="scene2"
      >
        <a-circle
          geometry="radius: 1.2"
          material="src: #thumbScene1; shader: flat; side: double"
          class="clickable portal-click"
          data-scene="scene2.html"
          data-room="scene2"
          event-set__mouseenter="material.opacity: 0.8"
          event-set__mouseleave="material.opacity: 1"
        ></a-circle>
        <a-ring
          geometry="radiusInner: 1.15; radiusOuter: 1.3"
          material="color: #4CC3D9; shader: flat; side: double; transparent: true; opacity: 0.6"
        ></a-ring>
        <a-text
          value="Go To World 2"
          position="0 1.5 0"
          align="center"
          color="#fff"
          scale="2 2 2"
        ></a-text>
      </a-entity>

      <!-- Portal 3: World 3 -->
      <a-entity
        id="portal-3"
        position="0 1.6 -12"
        class="clickable portal"
        data-scene="scane3.html"
        data-room="scene3"
      >
        <a-circle
          geometry="radius: 1.2"
          material="src: #thumbScene1; shader: flat; side: double"
          class="clickable portal-click"
          data-scene="scane3.html"
          data-room="scene3"
          event-set__mouseenter="material.opacity: 0.8"
          event-set__mouseleave="material.opacity: 1"
        ></a-circle>
        <a-ring
          geometry="radiusInner: 1.15; radiusOuter: 1.3"
          material="color: #4CC3D9; shader: flat; side: double; transparent: true; opacity: 0.6"
        ></a-ring>
        <a-text
          value="Go To World 3"
          position="0 1.5 0"
          align="center"
          color="#fff"
          scale="2 2 2"
        ></a-text>
      </a-entity>

      <a-entity id="scene">
        <!-- World GLB model -->
        <a-gltf-model src="assets/home/world.glb" position="0 0.2 0" scale="1 1 1" rotation="0 0 0"></a-gltf-model>

        <!-- Interior walls to prevent escape from inside world.glb -->
        <!-- These walls form the interior boundaries of the world -->

        <!-- Ultra small interior nav-mesh -->
        <a-box nav-mesh position="0 0 0" width="3" height="0.1" depth="3" visible="false"></a-box>

        <!-- Ultra tight boundary walls -->
        <!-- East interior wall -->
        <a-box nav-mesh position="1.5 2 0" width="0.1" height="4" depth="3" visible="false"></a-box>
        <!-- West interior wall -->
        <a-box nav-mesh position="-1.5 2 0" width="0.1" height="4" depth="3" visible="false"></a-box>
        <!-- North interior wall -->
        <a-box nav-mesh position="0 2 1.5" width="3" height="4" depth="0.1" visible="false"></a-box>
        <!-- South interior wall -->
        <a-box nav-mesh position="0 2 -1.5" width="3" height="4" depth="0.1" visible="false"></a-box>

        <!-- Corner blocks (extremely close) -->
        <a-box nav-mesh position="1.4 2 1.4" width="0.3" height="4" depth="0.3" visible="false"></a-box>
        <a-box nav-mesh position="-1.4 2 1.4" width="0.3" height="4" depth="0.3" visible="false"></a-box>
        <a-box nav-mesh position="1.4 2 -1.4" width="0.3" height="4" depth="0.3" visible="false"></a-box>
        <a-box nav-mesh position="-1.4 2 -1.4" width="0.3" height="4" depth="0.3" visible="false"></a-box>

        <!-- Ground -->
        <a-plane position="0 0 0" rotation="-90 0 0" width="100" height="100" color="#4A4A4A" visible="true"></a-plane>
        <a-entity light="type:ambient;intensity:0.5"></a-entity>
      </a-entity>

      <a-entity
        id="rig"
        movement-controls="constrainToNavMesh: true; speed: 0.3"
        spawn-in-circle="radius:1"
        networked="template:#avatar-template;attachTemplateToLocal:false"
        player-info
      >
        <a-entity id="player" class="camera" camera position="0 1.6 0" look-controls>
          <a-entity
            position="0 0 -1"
            geometry="primitive: ring; radiusInner: 0.018; radiusOuter: 0.025"
            material="shader: flat; opacity: 0.9"
            cursor="fuse: false; rayOrigin: mouse"
            raycaster="objects: .clickable, .portal, .portal-click; far: 20;"
            animation__reset="property: scale; startEvents: mouseleave; to: 1 1 1; dur: 120"
          >
          </a-entity>
        </a-entity>
        <a-entity id="left-hand" networked-hand-controls="hand: left" laser-controls="hand: left"></a-entity>
        <a-entity id="right-hand" networked-hand-controls="hand:right" laser-controls="hand: right"></a-entity>
      </a-entity>
    </a-scene>

    <script>
      // Initialize Networked-Aframe after everything is loaded
      function initializeNetworkedAFrame() {
        console.log('Initializing Networked-Aframe...');

        // Check if NAF and adapters are available
        if (typeof NAF === 'undefined' || !NAF.adapters || !NAF.adapters.EasyRtcAdapter) {
          console.error('Networked-Aframe or EasyRTC adapter not properly loaded');
          return;
        }

        // Configure the adapter
        try {
          NAF.connection.adapter = new NAF.adapters.EasyRtcAdapter();
          NAF.connection.adapter.setAppName('default');
          NAF.connection.adapter.setRoom('lobby');
          NAF.connection.adapter.setConnectOnLoad(true);
          NAF.connection.adapter.setServerUrl(window.location.origin);

          // Connect to the server
          const scene = document.querySelector('a-scene');
          if (scene.hasLoaded) {
            connectToServer();
          } else {
            scene.addEventListener('loaded', connectToServer);
          }
        } catch (error) {
          console.error('Error initializing NAF adapter:', error);
        }
      }

      function connectToServer() {
        console.log('Connecting to server...');
        const scene = document.querySelector('a-scene');
        const networkedScene = scene.systems['networked-scene'];

        if (networkedScene) {
          networkedScene.connect();
          console.log('Networked-Aframe connected successfully');
        } else {
          console.error('Networked-scene system not found');
        }
      }

      // Wait for DOM and A-Frame to be fully loaded
      document.addEventListener('DOMContentLoaded', () => {
        // Wait for A-Frame to be ready
        if (document.querySelector('a-scene').hasLoaded) {
          initNetworkedAFrame();
        } else {
          document.querySelector('a-scene').addEventListener('loaded', initNetworkedAFrame);
        }
      });

      function initNetworkedAFrame() {
        console.log('Initializing Networked-Aframe...');

        // Check if NAF is available
        if (typeof NAF === 'undefined') {
          console.error('Networked-Aframe not loaded');
          return;
        }

        // Configure NAF schema
        NAF.schemas.add({
          template: '#avatar-template',
          components: ['position', 'rotation', 'scale', 'player-info', 'model', 'nametag', 'camera'],
        });

        // Get server URL
        const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
        const serverUrl = isLocalhost ? 'http://localhost:8080' : window.location.origin;

        console.log('Connecting to server:', serverUrl);

        // Initialize NAF with error handling
        try {
          if (NAF.adapters && NAF.adapters.EasyRtcAdapter) {
            NAF.connection.adapter = new NAF.adapters.EasyRtcAdapter();
            NAF.connection.adapter.setServerUrl(serverUrl);
            NAF.connection.adapter.setApp('default');
            NAF.connection.adapter.setRoom('lobby');
            NAF.connection.adapter.setConnectOnLoad(true);

            NAF.connection.adapter.setServerConnectListeners({
              connect: (clientId) => {
                console.log('Connected to server with ID:', clientId);
              },
              disconnect: () => {
                console.log('Disconnected from server');
              },
            });

            // Connect to the server
            NAF.connection.connect();
          } else {
            console.warn('EasyRTC adapter not available, networking disabled');
          }
        } catch (error) {
          console.error('Error initializing NAF:', error);
        }
      }
    </script>

    <script>
      // Add animation class to cards on load
      document.addEventListener('DOMContentLoaded', () => {
        const cards = document.querySelectorAll('.selection-card');
        cards.forEach((card, index) => {
          // Staggered animation
          card.style.animation = `fadeInUp 0.5s ease-out ${index * 0.1}s forwards`;
          card.style.opacity = '0';

          // Add click effect
          card.addEventListener('mousedown', () => {
            card.style.transform = 'translateY(-5px) scale(0.98)';
          });

          card.addEventListener('mouseup', () => {
            card.style.transform = 'translateY(-10px)';
          });

          card.addEventListener('mouseleave', () => {
            if (!card.classList.contains('highlight')) {
              card.style.transform = 'translateY(0)';
            } else {
              card.style.transform = 'translateY(-10px)';
            }
          });
        });
      });

      // Add keyframe animation
      const style = document.createElement('style');
      style.textContent = `
      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      
      @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(156, 39, 176, 0.7); }
        70% { box-shadow: 0 0 0 10px rgba(156, 39, 176, 0); }
        100% { box-shadow: 0 0 0 0 rgba(156, 39, 176, 0); }
      }
      
      .selection-card.highlight {
        animation: pulse 2s infinite;
      }
    `;
      document.head.appendChild(style);

      // Check if we should show the device selection or main experience
      const deviceType = localStorage.getItem('deviceType');
      const deviceSelection = document.getElementById('device-selection');
      const mainContainer = document.querySelector('.main-container');
      const aScene = document.querySelector('a-scene');

      // ALWAYS show device selection first for vr.html, unless in a specific scene
      if (!deviceType) {
        // No device type selected, show selection screen
        if (deviceSelection) deviceSelection.style.display = 'flex';
        if (mainContainer) mainContainer.style.display = 'none';
        if (aScene) {
          aScene.style.display = 'none';
          // Completely disable scene to prevent any events
          aScene.pause();
        }
        
        // Prevent any auto-navigation while on device selection screen
        // Disable all change-room components
        setTimeout(() => {
          const sceneLinks = document.querySelectorAll('a-link');
          sceneLinks.forEach(link => {
            // Remove change-room attribute temporarily
            const changeRoomAttr = link.getAttribute('change-room');
            if (changeRoomAttr) {
              link.setAttribute('data-original-change-room', changeRoomAttr);
              link.removeAttribute('change-room');
            }
            // Disable click events
            link.setAttribute('data-disabled', 'true');
          });
        }, 100);
      } else {
        // Device type exists, show the scene
        if (mainContainer) mainContainer.style.display = 'none';
        if (deviceSelection) deviceSelection.style.display = 'none';
        if (aScene) aScene.style.display = 'block';
        // Initialize the experience based on device type
        initializeExperience(deviceType);
      }

      // Device selection handlers
      function setupDevice(deviceType) {
        // Hide the main menu and show the A-Frame scene
        if (mainContainer) mainContainer.style.display = 'none';
        if (deviceSelection) deviceSelection.style.display = 'none';
        if (aScene) {
          aScene.style.display = 'block';
          aScene.play();
          
          // Re-enable change-room components after device is selected
          setTimeout(() => {
            const sceneLinks = document.querySelectorAll('a-link');
            sceneLinks.forEach(link => {
              const originalChangeRoom = link.getAttribute('data-original-change-room');
              if (originalChangeRoom) {
                link.setAttribute('change-room', originalChangeRoom);
                link.removeAttribute('data-original-change-room');
              }
              link.removeAttribute('data-disabled');
            });
          }, 500);
        }

        // Save the device type to local storage
        localStorage.setItem('deviceType', deviceType);

        // Initialize the experience based on device type
        initializeExperience(deviceType);
      }

      // Function to initialize the experience based on device type
      function initializeExperience(deviceType) {
        // Handle desktop/mobile modes
        if (mobileControls) {
          mobileControls.style.display = deviceType === 'mobile' ? 'block' : 'none';
          if (deviceType === 'mobile') {
            setupMobileControls();
          }
        }
      }

        // Enhanced device button handlers with animations
        function setupDeviceButton(buttonId, deviceType) {
          const button = document.getElementById(buttonId);
          if (!button) return;

          button.addEventListener('click', () => {
            // Add click animation
            button.style.transform = 'scale(0.95)';
            setTimeout(() => {
              button.style.transform = '';
            }, 200);

            // Highlight selected device
            document.querySelectorAll('.selection-card').forEach((card) => {
              card.classList.remove('selected');
            });
            button.classList.add('selected');

            // Add loading state
            const originalContent = button.innerHTML;
            button.innerHTML = `
          <div class="loading-spinner">
            <div class="spinner"></div>
            <span>Menyiapkan...</span>
          </div>
        `;

            // Add spinner styles if not exists
            if (!document.getElementById('spinner-styles')) {
              const spinnerStyle = document.createElement('style');
              spinnerStyle.id = 'spinner-styles';
              spinnerStyle.textContent = `
            .loading-spinner {
              display: flex;
              flex-direction: column;
              align-items: center;
              gap: 10px;
            }
            .spinner {
              width: 20px;
              height: 20px;
              border: 3px solid rgba(255, 255, 255, 0.3);
              border-radius: 50%;
              border-top-color: #fff;
              animation: spin 1s ease-in-out infinite;
            }
            @keyframes spin {
              to { transform: rotate(360deg); }
            }
          `;
              document.head.appendChild(spinnerStyle);
            }

            // Proceed with device setup after a short delay
            setTimeout(() => {
              setupDevice(deviceType);
            }, 800);
          });

          // Add hover effect
          button.addEventListener('mouseenter', () => {
            if (!button.classList.contains('selected')) {
              button.style.transform = 'translateY(-5px)';
            }
          });

          button.addEventListener('mouseleave', () => {
            if (!button.classList.contains('selected')) {
              button.style.transform = 'translateY(0)';
            } else {
              button.style.transform = 'translateY(-10px)';
            }
          });
        }

        // Initialize device buttons
        setupDeviceButton('btn-desktop', 'desktop');
        setupDeviceButton('btn-mobile', 'mobile');

        // Setup portal click handlers - only allow explicit clicks
        function setupPortalHandlers() {
          // Handle both parent portal entities and child circles
          const portals = document.querySelectorAll('.portal, .portal-click');
          portals.forEach(portal => {
            // Remove any existing change-room component
            portal.removeAttribute('change-room');
            
            // Get scene and room from this element or parent
            let scene = portal.getAttribute('data-scene');
            let room = portal.getAttribute('data-room');
            
            // If not found, try parent
            if (!scene || !room) {
              const parent = portal.parentElement;
              if (parent) {
                scene = scene || parent.getAttribute('data-scene');
                room = room || parent.getAttribute('data-room');
              }
            }
            
            // Add explicit click handler using A-Frame event system
            portal.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              
              if (scene && room) {
                console.log('Portal clicked:', scene, room);
                // Use NAF to change room if available
                if (typeof NAF !== 'undefined' && NAF.connection && NAF.connection.adapter) {
                  NAF.connection.adapter.setRoom(room);
                }
                // Navigate to scene
                window.location.href = scene;
              }
            });
            
            // Also handle mousedown for better compatibility
            portal.addEventListener('mousedown', function(e) {
              e.preventDefault();
              e.stopPropagation();
              
              if (scene && room) {
                console.log('Portal mousedown:', scene, room);
                if (typeof NAF !== 'undefined' && NAF.connection && NAF.connection.adapter) {
                  NAF.connection.adapter.setRoom(room);
                }
                window.location.href = scene;
              }
            });
          });
        }

        // Setup portals after scene loads
        const sceneEl = document.querySelector('a-scene');
        if (sceneEl) {
          if (sceneEl.hasLoaded) {
            setupPortalHandlers();
          } else {
            sceneEl.addEventListener('loaded', setupPortalHandlers);
          }
        }

        // Function to start the experience (no avatar selection needed)
        function startExperience() {
          const scene = document.querySelector('a-scene');
          const deviceSelection = document.getElementById('device-selection');

          // Hide device selection
          deviceSelection.style.display = 'none';

          // Show the scene
          scene.style.display = 'block';

          // Use default avatar (male)
          const rig = document.getElementById('rig');
          if (rig) {
            const modelUrl = 'https://cdn.glitch.global/c2231c1a-2935-4332-8715-032588334f99/Asian_M_1_Busi.glb?v=16813662';
            rig.setAttribute('player-info', 'avatarSrc', modelUrl);
          }

          // Hide any avatar selection modals that might appear
          setTimeout(() => {
            const avatarModals = document.querySelectorAll('div[class*="naf-centered-fullscreen"], div[class*="avatar-selection"], div[id*="avatar"], .avatar-modal, .avatar-selection-modal');
            avatarModals.forEach(modal => {
              modal.style.display = 'none';
              modal.style.visibility = 'hidden';
            });
          }, 100);
        }

        // Prevent avatar selection modal from appearing
        document.addEventListener('DOMContentLoaded', () => {
          // Hide avatar selection modals immediately
          const observer = new MutationObserver(() => {
            const avatarModals = document.querySelectorAll('div[class*="naf-centered-fullscreen"], div[class*="avatar-selection"], div[id*="avatar"], .avatar-modal, .avatar-selection-modal');
            avatarModals.forEach(modal => {
              if (modal.textContent.includes('Pilih Avatar') || modal.textContent.includes('Avatar')) {
                modal.style.display = 'none';
                modal.style.visibility = 'hidden';
                modal.remove();
              }
            });
          });

          observer.observe(document.body, {
            childList: true,
            subtree: true
          });
        });


        // Initialize device based on stored preference
        if (deviceType) {
          deviceSelection.style.display = 'none';
          scene.style.display = 'block';

          if (deviceType === 'mobile') {
            if (mobileControls) {
              mobileControls.style.display = 'block';
              scene.addEventListener('loaded', function () {
                setTimeout(setupMobileControls, 1000);
              });
            }
        }

        // Initialize mobile controls
        function setupMobileControls() {
          const camera = document.querySelector('[camera]');
          const rig = document.getElementById('rig');

          if (!camera) {
            console.error('Camera element not found');
            return;
          }

          const movementSpeed = 0.1;
          let isMobile = false;

          // Initialize joystick
          function initJoystick() {
            // Remove any existing joystick
            if (joystick) {
              const joystickElement = document.getElementById('joystick');
              if (joystickElement) {
                joystickElement.innerHTML = '';
              }
            }

            joystick = new JoyStick(
              'joystick',
              {
                title: 'joystick',
                width: 225,
                height: 225,
                internalFillColor: 'rgba(255, 255, 255, 0.5)',
                internalLineWidth: 2,
                internalStrokeColor: '#FFFFFF',
                externalLineWidth: 2,
                externalStrokeColor: 'rgba(255, 255, 255, 0.3)',
                autoReturnToCenter: true,
              },
              function (stickData) {
                if (stickData.x !== 0 || stickData.y !== 0) {
                  updateCameraMovement(stickData.x, stickData.y);
                }
              },
            );
          }

          // Update camera movement based on joystick input
          function updateCameraMovement(x, y) {
            if (!camera) return;

            const cameraEl = camera.object3D;
            const direction = new THREE.Vector3();
            cameraEl.getWorldDirection(direction);

            // Project direction onto XZ plane (ignore Y-axis for movement)
            const forward = new THREE.Vector3(direction.x, 0, direction.z).normalize();

            // Calculate movement vector based on joystick input
            const moveX = x * movementSpeed;
            const moveZ = y * movementSpeed; // Positive Y moves forward, negative Y moves backward

            // Strafe movement (left/right) - use camera right vector
            const right = new THREE.Vector3();
            right.crossVectors(new THREE.Vector3(0, 1, 0), forward).normalize();

            // Calculate final movement direction
            const movement = new THREE.Vector3();
            // Forward/backward movement based on camera forward
            movement.addScaledVector(forward, moveZ);
            // Left/right strafing
            movement.addScaledVector(right, moveX);

            // Apply movement to camera position
            const currentPosition = camera.getAttribute('position');
            camera.setAttribute('position', {
              x: currentPosition.x + movement.x,
              y: currentPosition.y, // Keep Y position the same (no flying)
              z: currentPosition.z + movement.z,
            });
          }

          // Show joystick for mobile devices
          function checkDeviceType() {
            const deviceType = localStorage.getItem('deviceType');
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            console.log('Device type from localStorage:', deviceType);
            console.log('Is mobile device:', isMobile);

            // Show joystick if:
            // 1. User selected 'mobile' in localStorage, OR
            // 2. Device is detected as mobile (regardless of localStorage)
            if (deviceType === 'mobile' || isMobile) {
              console.log('Showing joystick for mobile device');
              document.getElementById('mobile-controls').style.display = 'block';
              initJoystick();
            } else {
              console.log('Hiding joystick for desktop');
              document.getElementById('mobile-controls').style.display = 'none';
            }
          }

          // Initialize mobile controls
          checkDeviceType();
        }
      }

    </script>
  </body>
</html>